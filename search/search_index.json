{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"mkdocs-autorefs \u00a4 Automatically link across pages in MkDocs. Installation \u00a4 With pip : python3 -m pip install mkdocs-autorefs Usage \u00a4 # mkdocs.yml plugins : - search - autorefs In one of your Markdown files (e.g. doc1.md ) create some headings: ## Hello, world! ## Another heading Link to [ Hello, World! ]( #hello-world ) on the same page. This is a normal link to an anchor . MkDocs generates anchors for each heading, and they can always be used to link to something, either within the same page (as shown here) or by specifying the path of the other page. But with this plugin, you can link to a heading from any other page on the site without needing to know the path of either of the pages, just the heading title itself. Let's create another Markdown page to try this, subdir/doc2.md : We can [ link to that heading ][ hello-world ] from another page too. This works the same as [ a normal link to that heading ]( ../doc1.md#hello-world ). Linking to a heading without needing to know the destination page can be useful if specifying that path is cumbersome, e.g. when the pages have deeply nested paths, are far apart, or are moved around frequently. And the issue is somewhat exacerbated by the fact that MkDocs supports only relative links between pages . Note that this plugin's behavior is undefined when trying to link to a heading title that appears several times throughout the site. Currently it arbitrarily chooses one of the pages. Requirements \u00a4 mkdocs-autorefs requires Python 3.7 or above. To install Python 3.7, I recommend using pyenv . # install pyenv git clone https://github.com/pyenv/pyenv ~/.pyenv # setup pyenv (you should also put these three lines in .bashrc or similar) export PATH = \" ${ HOME } /.pyenv/bin: ${ PATH } \" export PYENV_ROOT = \" ${ HOME } /.pyenv\" eval \" $( pyenv init - ) \" # install Python 3.7 pyenv install 3 .7.12 # make it available globally pyenv global system 3 .7.12","title":"Overview"},{"location":"#mkdocs-autorefs","text":"Automatically link across pages in MkDocs.","title":"mkdocs-autorefs"},{"location":"#installation","text":"With pip : python3 -m pip install mkdocs-autorefs","title":"Installation"},{"location":"#usage","text":"# mkdocs.yml plugins : - search - autorefs In one of your Markdown files (e.g. doc1.md ) create some headings: ## Hello, world! ## Another heading Link to [ Hello, World! ]( #hello-world ) on the same page. This is a normal link to an anchor . MkDocs generates anchors for each heading, and they can always be used to link to something, either within the same page (as shown here) or by specifying the path of the other page. But with this plugin, you can link to a heading from any other page on the site without needing to know the path of either of the pages, just the heading title itself. Let's create another Markdown page to try this, subdir/doc2.md : We can [ link to that heading ][ hello-world ] from another page too. This works the same as [ a normal link to that heading ]( ../doc1.md#hello-world ). Linking to a heading without needing to know the destination page can be useful if specifying that path is cumbersome, e.g. when the pages have deeply nested paths, are far apart, or are moved around frequently. And the issue is somewhat exacerbated by the fact that MkDocs supports only relative links between pages . Note that this plugin's behavior is undefined when trying to link to a heading title that appears several times throughout the site. Currently it arbitrarily chooses one of the pages.","title":"Usage"},{"location":"#requirements","text":"mkdocs-autorefs requires Python 3.7 or above. To install Python 3.7, I recommend using pyenv . # install pyenv git clone https://github.com/pyenv/pyenv ~/.pyenv # setup pyenv (you should also put these three lines in .bashrc or similar) export PATH = \" ${ HOME } /.pyenv/bin: ${ PATH } \" export PYENV_ROOT = \" ${ HOME } /.pyenv\" eval \" $( pyenv init - ) \" # install Python 3.7 pyenv install 3 .7.12 # make it available globally pyenv global system 3 .7.12","title":"Requirements"},{"location":"changelog/","text":"Changelog \u00a4 All notable changes to this project will be documented in this file. The format is based on Keep a Changelog and this project adheres to Semantic Versioning . 0.4.1 - 2022-03-07 \u00a4 Compare with 0.4.0 Bug Fixes \u00a4 Fix packaging (missing __init__ module) ( de0670b by Timoth\u00e9e Mazzucotelli). Issue #17 , issue mkdocstrings/mkdocstrings#398 , PR #18 0.4.0 - 2022-03-07 \u00a4 Compare with 0.3.1 Features \u00a4 Add HTML classes to references: autorefs always, and autorefs-internal or autorefs-external depending on the link ( 39db59d by Timoth\u00e9e Mazzucotelli). PR #16 Bug Fixes \u00a4 Don't compute relative URLs of already relative ones ( f6b861c by Timoth\u00e9e Mazzucotelli). PR #15 0.3.1 - 2021-12-27 \u00a4 Compare with 0.3.0 Code Refactoring \u00a4 Support fallback method returning multiple identifiers ( 0d2b411 by Timoth\u00e9e Mazzucotelli). Issue #11 , PR #12 and mkdocstrings#350 0.3.0 - 2021-07-24 \u00a4 Compare with 0.2.1 Features \u00a4 Add optional-hover ref type ( 0288bdd by Brian Koropoff). PR #10 0.2.1 - 2021-05-07 \u00a4 Compare with 0.2.0 Bug Fixes \u00a4 Prevent error during parallel installations ( c90e399 by Timoth\u00e9e Mazzucotelli). PR #9 0.2.0 - 2021-05-03 \u00a4 Compare with 0.1.1 Features \u00a4 Allow registering absolute URLs for autorefs ( 621686b by Oleh Prypin). PR #8 Allow external tools to insert references that are OK to skip ( 7619c28 by Oleh Prypin). PR #7 Allow [``identifier``][] , understood as [``identifier``][identifier] ( 2d3182d by Oleh Prypin). PR #5 0.1.1 - 2021-02-28 \u00a4 Compare with 0.1.0 Packaging \u00a4 Remove unused dependencies ( 9c6a8e6 by Oleh Prypin). 0.1.0 - 2021-02-17 \u00a4 Compare with first commit Features \u00a4 Split out \"mkdocs-autorefs\" plugin from \"mkdocstrings\" ( fe6faa5 by Oleh Prypin).","title":"Changelog"},{"location":"changelog/#changelog","text":"All notable changes to this project will be documented in this file. The format is based on Keep a Changelog and this project adheres to Semantic Versioning .","title":"Changelog"},{"location":"changelog/#041-2022-03-07","text":"Compare with 0.4.0","title":"0.4.1 - 2022-03-07"},{"location":"changelog/#bug-fixes","text":"Fix packaging (missing __init__ module) ( de0670b by Timoth\u00e9e Mazzucotelli). Issue #17 , issue mkdocstrings/mkdocstrings#398 , PR #18","title":"Bug Fixes"},{"location":"changelog/#040-2022-03-07","text":"Compare with 0.3.1","title":"0.4.0 - 2022-03-07"},{"location":"changelog/#features","text":"Add HTML classes to references: autorefs always, and autorefs-internal or autorefs-external depending on the link ( 39db59d by Timoth\u00e9e Mazzucotelli). PR #16","title":"Features"},{"location":"changelog/#bug-fixes_1","text":"Don't compute relative URLs of already relative ones ( f6b861c by Timoth\u00e9e Mazzucotelli). PR #15","title":"Bug Fixes"},{"location":"changelog/#031-2021-12-27","text":"Compare with 0.3.0","title":"0.3.1 - 2021-12-27"},{"location":"changelog/#code-refactoring","text":"Support fallback method returning multiple identifiers ( 0d2b411 by Timoth\u00e9e Mazzucotelli). Issue #11 , PR #12 and mkdocstrings#350","title":"Code Refactoring"},{"location":"changelog/#030-2021-07-24","text":"Compare with 0.2.1","title":"0.3.0 - 2021-07-24"},{"location":"changelog/#features_1","text":"Add optional-hover ref type ( 0288bdd by Brian Koropoff). PR #10","title":"Features"},{"location":"changelog/#021-2021-05-07","text":"Compare with 0.2.0","title":"0.2.1 - 2021-05-07"},{"location":"changelog/#bug-fixes_2","text":"Prevent error during parallel installations ( c90e399 by Timoth\u00e9e Mazzucotelli). PR #9","title":"Bug Fixes"},{"location":"changelog/#020-2021-05-03","text":"Compare with 0.1.1","title":"0.2.0 - 2021-05-03"},{"location":"changelog/#features_2","text":"Allow registering absolute URLs for autorefs ( 621686b by Oleh Prypin). PR #8 Allow external tools to insert references that are OK to skip ( 7619c28 by Oleh Prypin). PR #7 Allow [``identifier``][] , understood as [``identifier``][identifier] ( 2d3182d by Oleh Prypin). PR #5","title":"Features"},{"location":"changelog/#011-2021-02-28","text":"Compare with 0.1.0","title":"0.1.1 - 2021-02-28"},{"location":"changelog/#packaging","text":"Remove unused dependencies ( 9c6a8e6 by Oleh Prypin).","title":"Packaging"},{"location":"changelog/#010-2021-02-17","text":"Compare with first commit","title":"0.1.0 - 2021-02-17"},{"location":"changelog/#features_3","text":"Split out \"mkdocs-autorefs\" plugin from \"mkdocstrings\" ( fe6faa5 by Oleh Prypin).","title":"Features"},{"location":"code_of_conduct/","text":"Contributor Covenant Code of Conduct \u00a4 Our Pledge \u00a4 In the interest of fostering an open and welcoming environment, we as contributors and maintainers pledge to making participation in our project and our community a harassment-free experience for everyone, regardless of age, body size, disability, ethnicity, gender identity and expression, level of experience, nationality, personal appearance, race, religion, or sexual identity and orientation. Our Standards \u00a4 Examples of behavior that contributes to creating a positive environment include: Using welcoming and inclusive language Being respectful of differing viewpoints and experiences Gracefully accepting constructive criticism Focusing on what is best for the community Showing empathy towards other community members Examples of unacceptable behavior by participants include: The use of sexualized language or imagery and unwelcome sexual attention or advances Trolling, insulting/derogatory comments, and personal or political attacks Public or private harassment Publishing others' private information, such as a physical or electronic address, without explicit permission Other conduct which could reasonably be considered inappropriate in a professional setting Our Responsibilities \u00a4 Project maintainers are responsible for clarifying the standards of acceptable behavior and are expected to take appropriate and fair corrective action in response to any instances of unacceptable behavior. Project maintainers have the right and responsibility to remove, edit, or reject comments, commits, code, wiki edits, issues, and other contributions that are not aligned to this Code of Conduct, or to ban temporarily or permanently any contributor for other behaviors that they deem inappropriate, threatening, offensive, or harmful. Scope \u00a4 This Code of Conduct applies both within project spaces and in public spaces when an individual is representing the project or its community. Examples of representing a project or community include using an official project e-mail address, posting via an official social media account, or acting as an appointed representative at an online or offline event. Representation of a project may be further defined and clarified by project maintainers. Enforcement \u00a4 Instances of abusive, harassing, or otherwise unacceptable behavior may be reported by contacting the project team at pawamoy@pm.me . All complaints will be reviewed and investigated and will result in a response that is deemed necessary and appropriate to the circumstances. The project team is obligated to maintain confidentiality with regard to the reporter of an incident. Further details of specific enforcement policies may be posted separately. Project maintainers who do not follow or enforce the Code of Conduct in good faith may face temporary or permanent repercussions as determined by other members of the project's leadership. Attribution \u00a4 This Code of Conduct is adapted from the Contributor Covenant , version 1.4, available at http://contributor-covenant.org/version/1/4","title":"Code of Conduct"},{"location":"code_of_conduct/#contributor-covenant-code-of-conduct","text":"","title":"Contributor Covenant Code of Conduct"},{"location":"code_of_conduct/#our-pledge","text":"In the interest of fostering an open and welcoming environment, we as contributors and maintainers pledge to making participation in our project and our community a harassment-free experience for everyone, regardless of age, body size, disability, ethnicity, gender identity and expression, level of experience, nationality, personal appearance, race, religion, or sexual identity and orientation.","title":"Our Pledge"},{"location":"code_of_conduct/#our-standards","text":"Examples of behavior that contributes to creating a positive environment include: Using welcoming and inclusive language Being respectful of differing viewpoints and experiences Gracefully accepting constructive criticism Focusing on what is best for the community Showing empathy towards other community members Examples of unacceptable behavior by participants include: The use of sexualized language or imagery and unwelcome sexual attention or advances Trolling, insulting/derogatory comments, and personal or political attacks Public or private harassment Publishing others' private information, such as a physical or electronic address, without explicit permission Other conduct which could reasonably be considered inappropriate in a professional setting","title":"Our Standards"},{"location":"code_of_conduct/#our-responsibilities","text":"Project maintainers are responsible for clarifying the standards of acceptable behavior and are expected to take appropriate and fair corrective action in response to any instances of unacceptable behavior. Project maintainers have the right and responsibility to remove, edit, or reject comments, commits, code, wiki edits, issues, and other contributions that are not aligned to this Code of Conduct, or to ban temporarily or permanently any contributor for other behaviors that they deem inappropriate, threatening, offensive, or harmful.","title":"Our Responsibilities"},{"location":"code_of_conduct/#scope","text":"This Code of Conduct applies both within project spaces and in public spaces when an individual is representing the project or its community. Examples of representing a project or community include using an official project e-mail address, posting via an official social media account, or acting as an appointed representative at an online or offline event. Representation of a project may be further defined and clarified by project maintainers.","title":"Scope"},{"location":"code_of_conduct/#enforcement","text":"Instances of abusive, harassing, or otherwise unacceptable behavior may be reported by contacting the project team at pawamoy@pm.me . All complaints will be reviewed and investigated and will result in a response that is deemed necessary and appropriate to the circumstances. The project team is obligated to maintain confidentiality with regard to the reporter of an incident. Further details of specific enforcement policies may be posted separately. Project maintainers who do not follow or enforce the Code of Conduct in good faith may face temporary or permanent repercussions as determined by other members of the project's leadership.","title":"Enforcement"},{"location":"code_of_conduct/#attribution","text":"This Code of Conduct is adapted from the Contributor Covenant , version 1.4, available at http://contributor-covenant.org/version/1/4","title":"Attribution"},{"location":"contributing/","text":"Contributing \u00a4 Contributions are welcome, and they are greatly appreciated! Every little bit helps, and credit will always be given. Environment setup \u00a4 Nothing easier! Fork and clone the repository, then: cd mkdocs-autorefs make setup Note If it fails for some reason, you'll need to install PDM manually. You can install it with: python3 -m pip install --user pipx pipx install pdm Now you can try running make setup again, or simply pdm install . You now have the dependencies installed. You can run the application with pdm run mkdocs-autorefs [ARGS...] . Run make help to see all the available actions! Tasks \u00a4 This project uses duty to run tasks. A Makefile is also provided. The Makefile will try to run certain tasks on multiple Python versions. If for some reason you don't want to run the task on multiple Python versions, you can do one of the following: export PYTHON_VERSIONS= : this will run the task with only the current Python version run the task directly with pdm run duty TASK The Makefile detects if a virtual environment is activated, so make will work the same with the virtualenv activated or not. Development \u00a4 As usual: create a new branch: git checkout -b feature-or-bugfix-name edit the code and/or the documentation If you updated the documentation or the project dependencies: run make docs-regen run make docs-serve , go to http://localhost:8000 and check that everything looks good Before committing: run make format to auto-format the code run make check to check everything (fix any warning) run make test to run the tests (fix any issue) follow our commit message convention If you are unsure about how to fix or ignore a warning, just let the continuous integration fail, and we will help you during review. Don't bother updating the changelog, we will take care of this. Commit message convention \u00a4 Commits messages must follow the Angular style : <type>[(scope)]: Subject [Body] Scope and body are optional. Type can be: build : About packaging, building wheels, etc. chore : About packaging or repo/files management. ci : About Continuous Integration. docs : About documentation. feat : New feature. fix : Bug fix. perf : About performance. refactor : Changes which are not features nor bug fixes. style : A change in code style/format. tests : About tests. Subject (and body) must be valid Markdown. If you write a body, please add issues references at the end: Body. References: #10, #11. Fixes #15. Pull requests guidelines \u00a4 Link to any related issue in the Pull Request message. During review, we recommend using fixups: # SHA is the SHA of the commit you want to fix git commit --fixup = SHA Once all the changes are approved, you can squash your commits: git rebase -i --autosquash master And force-push: git push -f If this seems all too complicated, you can push or force-push each new commit, and we will squash them ourselves if needed, before merging.","title":"Contributing"},{"location":"contributing/#contributing","text":"Contributions are welcome, and they are greatly appreciated! Every little bit helps, and credit will always be given.","title":"Contributing"},{"location":"contributing/#environment-setup","text":"Nothing easier! Fork and clone the repository, then: cd mkdocs-autorefs make setup Note If it fails for some reason, you'll need to install PDM manually. You can install it with: python3 -m pip install --user pipx pipx install pdm Now you can try running make setup again, or simply pdm install . You now have the dependencies installed. You can run the application with pdm run mkdocs-autorefs [ARGS...] . Run make help to see all the available actions!","title":"Environment setup"},{"location":"contributing/#tasks","text":"This project uses duty to run tasks. A Makefile is also provided. The Makefile will try to run certain tasks on multiple Python versions. If for some reason you don't want to run the task on multiple Python versions, you can do one of the following: export PYTHON_VERSIONS= : this will run the task with only the current Python version run the task directly with pdm run duty TASK The Makefile detects if a virtual environment is activated, so make will work the same with the virtualenv activated or not.","title":"Tasks"},{"location":"contributing/#development","text":"As usual: create a new branch: git checkout -b feature-or-bugfix-name edit the code and/or the documentation If you updated the documentation or the project dependencies: run make docs-regen run make docs-serve , go to http://localhost:8000 and check that everything looks good Before committing: run make format to auto-format the code run make check to check everything (fix any warning) run make test to run the tests (fix any issue) follow our commit message convention If you are unsure about how to fix or ignore a warning, just let the continuous integration fail, and we will help you during review. Don't bother updating the changelog, we will take care of this.","title":"Development"},{"location":"contributing/#commit-message-convention","text":"Commits messages must follow the Angular style : <type>[(scope)]: Subject [Body] Scope and body are optional. Type can be: build : About packaging, building wheels, etc. chore : About packaging or repo/files management. ci : About Continuous Integration. docs : About documentation. feat : New feature. fix : Bug fix. perf : About performance. refactor : Changes which are not features nor bug fixes. style : A change in code style/format. tests : About tests. Subject (and body) must be valid Markdown. If you write a body, please add issues references at the end: Body. References: #10, #11. Fixes #15.","title":"Commit message convention"},{"location":"contributing/#pull-requests-guidelines","text":"Link to any related issue in the Pull Request message. During review, we recommend using fixups: # SHA is the SHA of the commit you want to fix git commit --fixup = SHA Once all the changes are approved, you can squash your commits: git rebase -i --autosquash master And force-push: git push -f If this seems all too complicated, you can push or force-push each new commit, and we will squash them ourselves if needed, before merging.","title":"Pull requests guidelines"},{"location":"credits/","text":"Credits \u00a4 These projects were used to build mkdocs-autorefs . Thank you! python | pdm | copier-pdm Direct dependencies \u00a4 autoflake | bandit | black | darglint | duty | flake8-bandit | flake8-black | flake8-bugbear | flake8-builtins | flake8-comprehensions | flake8-docstrings | flake8-pytest-style | flake8-string-format | flake8-tidy-imports | flake8-variables-names | git-changelog | isort | markdown | mkdocs | mkdocs-coverage | mkdocs-gen-files | mkdocs-literate-nav | mkdocs-material | mkdocs-section-index | mkdocstrings | mypy | pep8-naming | pytest | pytest-cov | pytest-randomly | pytest-sugar | pytest-xdist | safety | toml | types-markdown | types-toml | wps-light Indirect dependencies \u00a4 ansimarkup | astor | astunparse | atomicwrites | attrs | cached-property | certifi | charset-normalizer | click | colorama | coverage | dparse | execnet | failprint | flake8 | flake8-plugin-utils | flake8-polyfill | ghp-import | gitdb | gitpython | idna | importlib-metadata | iniconfig | jinja2 | markupsafe | mccabe | mergedeep | mkdocs-autorefs | mkdocs-material-extensions | mkdocstrings-python-legacy | mypy-extensions | packaging | pathspec | pbr | platformdirs | pluggy | ptyprocess | py | pycodestyle | pydocstyle | pyflakes | pygments | pymdown-extensions | pyparsing | pytest-forked | python-dateutil | pytkdocs | pyyaml | pyyaml-env-tag | requests | semver | setuptools | six | smmap | snowballstemmer | stevedore | termcolor | tomli | typed-ast | typing-extensions | urllib3 | watchdog | wheel | zipp More credits from the author","title":"Credits"},{"location":"credits/#credits","text":"These projects were used to build mkdocs-autorefs . Thank you! python | pdm | copier-pdm","title":"Credits"},{"location":"credits/#direct-dependencies","text":"autoflake | bandit | black | darglint | duty | flake8-bandit | flake8-black | flake8-bugbear | flake8-builtins | flake8-comprehensions | flake8-docstrings | flake8-pytest-style | flake8-string-format | flake8-tidy-imports | flake8-variables-names | git-changelog | isort | markdown | mkdocs | mkdocs-coverage | mkdocs-gen-files | mkdocs-literate-nav | mkdocs-material | mkdocs-section-index | mkdocstrings | mypy | pep8-naming | pytest | pytest-cov | pytest-randomly | pytest-sugar | pytest-xdist | safety | toml | types-markdown | types-toml | wps-light","title":"Direct dependencies"},{"location":"credits/#indirect-dependencies","text":"ansimarkup | astor | astunparse | atomicwrites | attrs | cached-property | certifi | charset-normalizer | click | colorama | coverage | dparse | execnet | failprint | flake8 | flake8-plugin-utils | flake8-polyfill | ghp-import | gitdb | gitpython | idna | importlib-metadata | iniconfig | jinja2 | markupsafe | mccabe | mergedeep | mkdocs-autorefs | mkdocs-material-extensions | mkdocstrings-python-legacy | mypy-extensions | packaging | pathspec | pbr | platformdirs | pluggy | ptyprocess | py | pycodestyle | pydocstyle | pyflakes | pygments | pymdown-extensions | pyparsing | pytest-forked | python-dateutil | pytkdocs | pyyaml | pyyaml-env-tag | requests | semver | setuptools | six | smmap | snowballstemmer | stevedore | termcolor | tomli | typed-ast | typing-extensions | urllib3 | watchdog | wheel | zipp More credits from the author","title":"Indirect dependencies"},{"location":"license/","text":"ISC License Copyright (c) 2019, Oleh Prypin Copyright (c) 2019, Timoth\u00e9e Mazzucotelli Permission to use, copy, modify, and/or distribute this software for any purpose with or without fee is hereby granted, provided that the above copyright notice and this permission notice appear in all copies. THE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.","title":"License"},{"location":"reference/SUMMARY/","text":"mkdocs_autorefs plugin references","title":"SUMMARY"},{"location":"reference/mkdocs_autorefs/","text":"mkdocs-autorefs package. Automatically link across pages in MkDocs. plugin \u00a4 This module contains the \"mkdocs-autorefs\" plugin. After each page is processed by the Markdown converter, this plugin stores absolute URLs of every HTML anchors it finds to later be able to fix unresolved references. It stores them during the on_page_content event hook . Just before writing the final HTML to the disc, during the on_post_page event hook , this plugin searches for references of the form [identifier][] or [title][identifier] that were not resolved, and fixes them using the previously stored identifier-URL mapping. AutorefsPlugin ( BasePlugin ) \u00a4 An mkdocs plugin. This plugin defines the following event hooks: on_config on_page_content on_post_page Check the Developing Plugins page of mkdocs for more information about its plugin system. Source code in mkdocs_autorefs/plugin.py class AutorefsPlugin ( BasePlugin ): \"\"\"An `mkdocs` plugin. This plugin defines the following event hooks: - `on_config` - `on_page_content` - `on_post_page` Check the [Developing Plugins](https://www.mkdocs.org/user-guide/plugins/#developing-plugins) page of `mkdocs` for more information about its plugin system. \"\"\" scan_toc : bool = True current_page : Optional [ str ] = None def __init__ ( self ) -> None : \"\"\"Initialize the object.\"\"\" super () . __init__ () self . _url_map : Dict [ str , str ] = {} self . _abs_url_map : Dict [ str , str ] = {} self . get_fallback_anchor : Optional [ Callable [[ str ], Optional [ str ]]] = None # noqa: WPS234 def register_anchor ( self , page : str , identifier : str ): \"\"\"Register that an anchor corresponding to an identifier was encountered when rendering the page. Arguments: page: The relative URL of the current page. Examples: `'foo/bar/'`, `'foo/index.html'` identifier: The HTML anchor (without '#') as a string. \"\"\" self . _url_map [ identifier ] = f \" { page } # { identifier } \" def register_url ( self , identifier : str , url : str ): \"\"\"Register that the identifier should be turned into a link to this URL. Arguments: identifier: The new identifier. url: The absolute URL (including anchor, if needed) where this item can be found. \"\"\" self . _abs_url_map [ identifier ] = url def _get_item_url ( # noqa: WPS234 self , identifier : str , fallback : Optional [ Callable [[ str ], Sequence [ str ]]] = None , ) -> str : try : return self . _url_map [ identifier ] except KeyError : if identifier in self . _abs_url_map : return self . _abs_url_map [ identifier ] if fallback : new_identifiers = fallback ( identifier ) for new_identifier in new_identifiers : with contextlib . suppress ( KeyError ): url = self . _get_item_url ( new_identifier ) self . _url_map [ identifier ] = url return url raise def get_item_url ( # noqa: WPS234 self , identifier : str , from_url : Optional [ str ] = None , fallback : Optional [ Callable [[ str ], Sequence [ str ]]] = None , ) -> str : \"\"\"Return a site-relative URL with anchor to the identifier, if it's present anywhere. Arguments: identifier: The anchor (without '#'). from_url: The URL of the base page, from which we link towards the targeted pages. fallback: An optional function to suggest alternative anchors to try on failure. Returns: A site-relative URL. \"\"\" url = self . _get_item_url ( identifier , fallback ) if from_url is not None : parsed = urlsplit ( url ) if not parsed . scheme and not parsed . netloc : return relative_url ( from_url , url ) return url def on_config ( self , config : Config , ** kwargs ) -> Config : # noqa: W0613,R0201 (unused arguments, cannot be static) \"\"\"Instantiate our Markdown extension. Hook for the [`on_config` event](https://www.mkdocs.org/user-guide/plugins/#on_config). In this hook, we instantiate our [`AutorefsExtension`][mkdocs_autorefs.references.AutorefsExtension] and add it to the list of Markdown extensions used by `mkdocs`. Arguments: config: The MkDocs config object. kwargs: Additional arguments passed by MkDocs. Returns: The modified config. \"\"\" log . debug ( f \" { __name__ } : Adding AutorefsExtension to the list\" ) config [ \"markdown_extensions\" ] . append ( AutorefsExtension ()) return config def on_page_markdown ( self , markdown : str , page : Page , ** kwargs ) -> str : # noqa: W0613 (unused arguments) \"\"\"Remember which page is the current one. Arguments: markdown: Input Markdown. page: The related MkDocs page instance. kwargs: Additional arguments passed by MkDocs. Returns: The same Markdown. We only use this hook to map anchors to URLs. \"\"\" self . current_page = page . url # noqa: WPS601 return markdown def on_page_content ( self , html : str , page : Page , ** kwargs ) -> str : # noqa: W0613 (unused arguments) \"\"\"Map anchors to URLs. Hook for the [`on_page_content` event](https://www.mkdocs.org/user-guide/plugins/#on_page_content). In this hook, we map the IDs of every anchor found in the table of contents to the anchors absolute URLs. This mapping will be used later to fix unresolved reference of the form `[title][identifier]` or `[identifier][]`. Arguments: html: HTML converted from Markdown. page: The related MkDocs page instance. kwargs: Additional arguments passed by MkDocs. Returns: The same HTML. We only use this hook to map anchors to URLs. \"\"\" if self . scan_toc : log . debug ( f \" { __name__ } : Mapping identifiers to URLs for page { page . file . src_path } \" ) for item in page . toc . items : self . map_urls ( page . url , item ) return html def map_urls ( self , base_url : str , anchor : AnchorLink ) -> None : \"\"\"Recurse on every anchor to map its ID to its absolute URL. This method populates `self.url_map` by side-effect. Arguments: base_url: The base URL to use as a prefix for each anchor's relative URL. anchor: The anchor to process and to recurse on. \"\"\" self . register_anchor ( base_url , anchor . id ) for child in anchor . children : self . map_urls ( base_url , child ) def on_post_page ( self , output : str , page : Page , ** kwargs ) -> str : # noqa: W0613 (unused arguments) \"\"\"Fix cross-references. Hook for the [`on_post_page` event](https://www.mkdocs.org/user-guide/plugins/#on_post_page). In this hook, we try to fix unresolved references of the form `[title][identifier]` or `[identifier][]`. Doing that allows the user of `autorefs` to cross-reference objects in their documentation strings. It uses the native Markdown syntax so it's easy to remember and use. We log a warning for each reference that we couldn't map to an URL, but try to be smart and ignore identifiers that do not look legitimate (sometimes documentation can contain strings matching our [`AUTO_REF_RE`][mkdocs_autorefs.references.AUTO_REF_RE] regular expression that did not intend to reference anything). We currently ignore references when their identifier contains a space or a slash. Arguments: output: HTML converted from Markdown. page: The related MkDocs page instance. kwargs: Additional arguments passed by MkDocs. Returns: Modified HTML. \"\"\" log . debug ( f \" { __name__ } : Fixing references in page { page . file . src_path } \" ) url_mapper = functools . partial ( self . get_item_url , from_url = page . url , fallback = self . get_fallback_anchor ) fixed_output , unmapped = fix_refs ( output , url_mapper ) if unmapped and log . isEnabledFor ( logging . WARNING ): for ref in unmapped : log . warning ( f \" { __name__ } : { page . file . src_path } : Could not find cross-reference target '[ { ref } ]'\" , ) return fixed_output __init__ ( self ) special \u00a4 Initialize the object. Source code in mkdocs_autorefs/plugin.py def __init__ ( self ) -> None : \"\"\"Initialize the object.\"\"\" super () . __init__ () self . _url_map : Dict [ str , str ] = {} self . _abs_url_map : Dict [ str , str ] = {} self . get_fallback_anchor : Optional [ Callable [[ str ], Optional [ str ]]] = None # noqa: WPS234 get_item_url ( self , identifier , from_url = None , fallback = None ) \u00a4 Return a site-relative URL with anchor to the identifier, if it's present anywhere. Parameters: Name Type Description Default identifier str The anchor (without '#'). required from_url Optional[str] The URL of the base page, from which we link towards the targeted pages. None fallback Optional[Callable[[str], Sequence[str]]] An optional function to suggest alternative anchors to try on failure. None Returns: Type Description str A site-relative URL. Source code in mkdocs_autorefs/plugin.py def get_item_url ( # noqa: WPS234 self , identifier : str , from_url : Optional [ str ] = None , fallback : Optional [ Callable [[ str ], Sequence [ str ]]] = None , ) -> str : \"\"\"Return a site-relative URL with anchor to the identifier, if it's present anywhere. Arguments: identifier: The anchor (without '#'). from_url: The URL of the base page, from which we link towards the targeted pages. fallback: An optional function to suggest alternative anchors to try on failure. Returns: A site-relative URL. \"\"\" url = self . _get_item_url ( identifier , fallback ) if from_url is not None : parsed = urlsplit ( url ) if not parsed . scheme and not parsed . netloc : return relative_url ( from_url , url ) return url map_urls ( self , base_url , anchor ) \u00a4 Recurse on every anchor to map its ID to its absolute URL. This method populates self.url_map by side-effect. Parameters: Name Type Description Default base_url str The base URL to use as a prefix for each anchor's relative URL. required anchor AnchorLink The anchor to process and to recurse on. required Source code in mkdocs_autorefs/plugin.py def map_urls ( self , base_url : str , anchor : AnchorLink ) -> None : \"\"\"Recurse on every anchor to map its ID to its absolute URL. This method populates `self.url_map` by side-effect. Arguments: base_url: The base URL to use as a prefix for each anchor's relative URL. anchor: The anchor to process and to recurse on. \"\"\" self . register_anchor ( base_url , anchor . id ) for child in anchor . children : self . map_urls ( base_url , child ) on_config ( self , config , ** kwargs ) \u00a4 Instantiate our Markdown extension. Hook for the on_config event . In this hook, we instantiate our AutorefsExtension and add it to the list of Markdown extensions used by mkdocs . Parameters: Name Type Description Default config Config The MkDocs config object. required kwargs Additional arguments passed by MkDocs. {} Returns: Type Description Config The modified config. Source code in mkdocs_autorefs/plugin.py def on_config ( self , config : Config , ** kwargs ) -> Config : # noqa: W0613,R0201 (unused arguments, cannot be static) \"\"\"Instantiate our Markdown extension. Hook for the [`on_config` event](https://www.mkdocs.org/user-guide/plugins/#on_config). In this hook, we instantiate our [`AutorefsExtension`][mkdocs_autorefs.references.AutorefsExtension] and add it to the list of Markdown extensions used by `mkdocs`. Arguments: config: The MkDocs config object. kwargs: Additional arguments passed by MkDocs. Returns: The modified config. \"\"\" log . debug ( f \" { __name__ } : Adding AutorefsExtension to the list\" ) config [ \"markdown_extensions\" ] . append ( AutorefsExtension ()) return config on_page_content ( self , html , page , ** kwargs ) \u00a4 Map anchors to URLs. Hook for the on_page_content event . In this hook, we map the IDs of every anchor found in the table of contents to the anchors absolute URLs. This mapping will be used later to fix unresolved reference of the form [title][identifier] or [identifier][] . Parameters: Name Type Description Default html str HTML converted from Markdown. required page Page The related MkDocs page instance. required kwargs Additional arguments passed by MkDocs. {} Returns: Type Description str The same HTML. We only use this hook to map anchors to URLs. Source code in mkdocs_autorefs/plugin.py def on_page_content ( self , html : str , page : Page , ** kwargs ) -> str : # noqa: W0613 (unused arguments) \"\"\"Map anchors to URLs. Hook for the [`on_page_content` event](https://www.mkdocs.org/user-guide/plugins/#on_page_content). In this hook, we map the IDs of every anchor found in the table of contents to the anchors absolute URLs. This mapping will be used later to fix unresolved reference of the form `[title][identifier]` or `[identifier][]`. Arguments: html: HTML converted from Markdown. page: The related MkDocs page instance. kwargs: Additional arguments passed by MkDocs. Returns: The same HTML. We only use this hook to map anchors to URLs. \"\"\" if self . scan_toc : log . debug ( f \" { __name__ } : Mapping identifiers to URLs for page { page . file . src_path } \" ) for item in page . toc . items : self . map_urls ( page . url , item ) return html on_page_markdown ( self , markdown , page , ** kwargs ) \u00a4 Remember which page is the current one. Parameters: Name Type Description Default markdown str Input Markdown. required page Page The related MkDocs page instance. required kwargs Additional arguments passed by MkDocs. {} Returns: Type Description str The same Markdown. We only use this hook to map anchors to URLs. Source code in mkdocs_autorefs/plugin.py def on_page_markdown ( self , markdown : str , page : Page , ** kwargs ) -> str : # noqa: W0613 (unused arguments) \"\"\"Remember which page is the current one. Arguments: markdown: Input Markdown. page: The related MkDocs page instance. kwargs: Additional arguments passed by MkDocs. Returns: The same Markdown. We only use this hook to map anchors to URLs. \"\"\" self . current_page = page . url # noqa: WPS601 return markdown on_post_page ( self , output , page , ** kwargs ) \u00a4 Fix cross-references. Hook for the on_post_page event . In this hook, we try to fix unresolved references of the form [title][identifier] or [identifier][] . Doing that allows the user of autorefs to cross-reference objects in their documentation strings. It uses the native Markdown syntax so it's easy to remember and use. We log a warning for each reference that we couldn't map to an URL, but try to be smart and ignore identifiers that do not look legitimate (sometimes documentation can contain strings matching our AUTO_REF_RE regular expression that did not intend to reference anything). We currently ignore references when their identifier contains a space or a slash. Parameters: Name Type Description Default output str HTML converted from Markdown. required page Page The related MkDocs page instance. required kwargs Additional arguments passed by MkDocs. {} Returns: Type Description str Modified HTML. Source code in mkdocs_autorefs/plugin.py def on_post_page ( self , output : str , page : Page , ** kwargs ) -> str : # noqa: W0613 (unused arguments) \"\"\"Fix cross-references. Hook for the [`on_post_page` event](https://www.mkdocs.org/user-guide/plugins/#on_post_page). In this hook, we try to fix unresolved references of the form `[title][identifier]` or `[identifier][]`. Doing that allows the user of `autorefs` to cross-reference objects in their documentation strings. It uses the native Markdown syntax so it's easy to remember and use. We log a warning for each reference that we couldn't map to an URL, but try to be smart and ignore identifiers that do not look legitimate (sometimes documentation can contain strings matching our [`AUTO_REF_RE`][mkdocs_autorefs.references.AUTO_REF_RE] regular expression that did not intend to reference anything). We currently ignore references when their identifier contains a space or a slash. Arguments: output: HTML converted from Markdown. page: The related MkDocs page instance. kwargs: Additional arguments passed by MkDocs. Returns: Modified HTML. \"\"\" log . debug ( f \" { __name__ } : Fixing references in page { page . file . src_path } \" ) url_mapper = functools . partial ( self . get_item_url , from_url = page . url , fallback = self . get_fallback_anchor ) fixed_output , unmapped = fix_refs ( output , url_mapper ) if unmapped and log . isEnabledFor ( logging . WARNING ): for ref in unmapped : log . warning ( f \" { __name__ } : { page . file . src_path } : Could not find cross-reference target '[ { ref } ]'\" , ) return fixed_output register_anchor ( self , page , identifier ) \u00a4 Register that an anchor corresponding to an identifier was encountered when rendering the page. Parameters: Name Type Description Default page str The relative URL of the current page. Examples: 'foo/bar/' , 'foo/index.html' required identifier str The HTML anchor (without '#') as a string. required Source code in mkdocs_autorefs/plugin.py def register_anchor ( self , page : str , identifier : str ): \"\"\"Register that an anchor corresponding to an identifier was encountered when rendering the page. Arguments: page: The relative URL of the current page. Examples: `'foo/bar/'`, `'foo/index.html'` identifier: The HTML anchor (without '#') as a string. \"\"\" self . _url_map [ identifier ] = f \" { page } # { identifier } \" register_url ( self , identifier , url ) \u00a4 Register that the identifier should be turned into a link to this URL. Parameters: Name Type Description Default identifier str The new identifier. required url str The absolute URL (including anchor, if needed) where this item can be found. required Source code in mkdocs_autorefs/plugin.py def register_url ( self , identifier : str , url : str ): \"\"\"Register that the identifier should be turned into a link to this URL. Arguments: identifier: The new identifier. url: The absolute URL (including anchor, if needed) where this item can be found. \"\"\" self . _abs_url_map [ identifier ] = url references \u00a4 Cross-references module. AUTO_REF_RE \u00a4 A regular expression to match mkdocs-autorefs' special reference markers in the on_post_page hook . AutoRefInlineProcessor ( ReferenceInlineProcessor ) \u00a4 A Markdown extension. Source code in mkdocs_autorefs/references.py class AutoRefInlineProcessor ( ReferenceInlineProcessor ): \"\"\"A Markdown extension.\"\"\" def __init__ ( self , * args , ** kwargs ): # noqa: D107 super () . __init__ ( REFERENCE_RE , * args , ** kwargs ) # Code based on # https://github.com/Python-Markdown/markdown/blob/8e7528fa5c98bf4652deb13206d6e6241d61630b/markdown/inlinepatterns.py#L780 def handleMatch ( self , m , data ) -> Union [ Element , EvalIDType ]: # type: ignore[override] # noqa: N802,WPS111 \"\"\"Handle an element that matched. Arguments: m: The match object. data: The matched data. Returns: A new element or a tuple. \"\"\" text , index , handled = self . getText ( data , m . end ( 0 )) if not handled : return None , None , None identifier , end , handled = self . evalId ( data , index , text ) if not handled : return None , None , None if re . search ( r \"[/ \\x00-\\x1f]\" , identifier ): # Do nothing if the matched reference contains: # - a space, slash or control character (considered unintended); # - specifically \\x01 is used by Python-Markdown HTML stash when there's inline formatting, # but references with Markdown formatting are not possible anyway. return None , m . start ( 0 ), end return self . makeTag ( identifier , text ), m . start ( 0 ), end def evalId ( self , data : str , index : int , text : str ) -> EvalIDType : # noqa: N802 (parent's casing) \"\"\"Evaluate the id portion of `[ref][id]`. If `[ref][]` use `[ref]`. Arguments: data: The data to evaluate. index: The starting position. text: The text to use when no identifier. Returns: A tuple containing the identifier, its end position, and whether it matched. \"\"\" m = self . RE_LINK . match ( data , pos = index ) # noqa: WPS111 if not m : return None , index , False identifier = m . group ( 1 ) if not identifier : identifier = text # Allow the entire content to be one placeholder, with the intent of catching things like [`Foo`][]. # It doesn't catch [*Foo*][] though, just due to the priority order. # https://github.com/Python-Markdown/markdown/blob/1858c1b601ead62ed49646ae0d99298f41b1a271/markdown/inlinepatterns.py#L78 if INLINE_PLACEHOLDER_RE . fullmatch ( identifier ): identifier = self . unescape ( identifier ) end = m . end ( 0 ) return identifier , end , True def makeTag ( self , identifier : str , text : str ) -> Element : # type: ignore[override] # noqa: N802,W0221 \"\"\"Create a tag that can be matched by `AUTO_REF_RE`. Arguments: identifier: The identifier to use in the HTML property. text: The text to use in the HTML tag. Returns: A new element. \"\"\" el = Element ( \"span\" ) el . set ( \"data-autorefs-identifier\" , identifier ) el . text = text return el evalId ( self , data , index , text ) \u00a4 Evaluate the id portion of [ref][id] . If [ref][] use [ref] . Parameters: Name Type Description Default data str The data to evaluate. required index int The starting position. required text str The text to use when no identifier. required Returns: Type Description Tuple[Any, Any, Any] A tuple containing the identifier, its end position, and whether it matched. Source code in mkdocs_autorefs/references.py def evalId ( self , data : str , index : int , text : str ) -> EvalIDType : # noqa: N802 (parent's casing) \"\"\"Evaluate the id portion of `[ref][id]`. If `[ref][]` use `[ref]`. Arguments: data: The data to evaluate. index: The starting position. text: The text to use when no identifier. Returns: A tuple containing the identifier, its end position, and whether it matched. \"\"\" m = self . RE_LINK . match ( data , pos = index ) # noqa: WPS111 if not m : return None , index , False identifier = m . group ( 1 ) if not identifier : identifier = text # Allow the entire content to be one placeholder, with the intent of catching things like [`Foo`][]. # It doesn't catch [*Foo*][] though, just due to the priority order. # https://github.com/Python-Markdown/markdown/blob/1858c1b601ead62ed49646ae0d99298f41b1a271/markdown/inlinepatterns.py#L78 if INLINE_PLACEHOLDER_RE . fullmatch ( identifier ): identifier = self . unescape ( identifier ) end = m . end ( 0 ) return identifier , end , True handleMatch ( self , m , data ) \u00a4 Handle an element that matched. Parameters: Name Type Description Default m The match object. required data The matched data. required Returns: Type Description Union[xml.etree.ElementTree.Element, Tuple[Any, Any, Any]] A new element or a tuple. Source code in mkdocs_autorefs/references.py def handleMatch ( self , m , data ) -> Union [ Element , EvalIDType ]: # type: ignore[override] # noqa: N802,WPS111 \"\"\"Handle an element that matched. Arguments: m: The match object. data: The matched data. Returns: A new element or a tuple. \"\"\" text , index , handled = self . getText ( data , m . end ( 0 )) if not handled : return None , None , None identifier , end , handled = self . evalId ( data , index , text ) if not handled : return None , None , None if re . search ( r \"[/ \\x00-\\x1f]\" , identifier ): # Do nothing if the matched reference contains: # - a space, slash or control character (considered unintended); # - specifically \\x01 is used by Python-Markdown HTML stash when there's inline formatting, # but references with Markdown formatting are not possible anyway. return None , m . start ( 0 ), end return self . makeTag ( identifier , text ), m . start ( 0 ), end makeTag ( self , identifier , text ) \u00a4 Create a tag that can be matched by AUTO_REF_RE . Parameters: Name Type Description Default identifier str The identifier to use in the HTML property. required text str The text to use in the HTML tag. required Returns: Type Description Element A new element. Source code in mkdocs_autorefs/references.py def makeTag ( self , identifier : str , text : str ) -> Element : # type: ignore[override] # noqa: N802,W0221 \"\"\"Create a tag that can be matched by `AUTO_REF_RE`. Arguments: identifier: The identifier to use in the HTML property. text: The text to use in the HTML tag. Returns: A new element. \"\"\" el = Element ( \"span\" ) el . set ( \"data-autorefs-identifier\" , identifier ) el . text = text return el AutorefsExtension ( Extension ) \u00a4 Extension that inserts auto-references in Markdown. Source code in mkdocs_autorefs/references.py class AutorefsExtension ( Extension ): \"\"\"Extension that inserts auto-references in Markdown.\"\"\" def extendMarkdown ( self , md : Markdown ) -> None : # noqa: N802 (casing: parent method's name) \"\"\"Register the extension. Add an instance of our [`AutoRefInlineProcessor`][mkdocs_autorefs.references.AutoRefInlineProcessor] to the Markdown parser. Arguments: md: A `markdown.Markdown` instance. \"\"\" md . inlinePatterns . register ( AutoRefInlineProcessor ( md ), \"mkdocs-autorefs\" , priority = 168 , # noqa: WPS432 # Right after markdown.inlinepatterns.ReferenceInlineProcessor ) extendMarkdown ( self , md ) \u00a4 Register the extension. Add an instance of our AutoRefInlineProcessor to the Markdown parser. Parameters: Name Type Description Default md Markdown A markdown.Markdown instance. required Source code in mkdocs_autorefs/references.py def extendMarkdown ( self , md : Markdown ) -> None : # noqa: N802 (casing: parent method's name) \"\"\"Register the extension. Add an instance of our [`AutoRefInlineProcessor`][mkdocs_autorefs.references.AutoRefInlineProcessor] to the Markdown parser. Arguments: md: A `markdown.Markdown` instance. \"\"\" md . inlinePatterns . register ( AutoRefInlineProcessor ( md ), \"mkdocs-autorefs\" , priority = 168 , # noqa: WPS432 # Right after markdown.inlinepatterns.ReferenceInlineProcessor ) fix_ref ( url_mapper , unmapped ) \u00a4 Return a repl function for re.sub . In our context, we match Markdown references and replace them with HTML links. When the matched reference's identifier was not mapped to an URL, we append the identifier to the outer unmapped list. It generally means the user is trying to cross-reference an object that was not collected and rendered, making it impossible to link to it. We catch this exception in the caller to issue a warning. Parameters: Name Type Description Default url_mapper Callable[[str], str] A callable that gets an object's site URL by its identifier, such as mkdocs_autorefs.plugin.AutorefsPlugin.get_item_url . required unmapped List[str] A list to store unmapped identifiers. required Returns: Type Description The actual function accepting a [`Match` object](https //docs.python.org/3/library/re.html#match-objects) and returning the replacement strings. Source code in mkdocs_autorefs/references.py def fix_ref ( url_mapper : Callable [[ str ], str ], unmapped : List [ str ]) -> Callable : # noqa: WPS212,WPS231 \"\"\"Return a `repl` function for [`re.sub`](https://docs.python.org/3/library/re.html#re.sub). In our context, we match Markdown references and replace them with HTML links. When the matched reference's identifier was not mapped to an URL, we append the identifier to the outer `unmapped` list. It generally means the user is trying to cross-reference an object that was not collected and rendered, making it impossible to link to it. We catch this exception in the caller to issue a warning. Arguments: url_mapper: A callable that gets an object's site URL by its identifier, such as [mkdocs_autorefs.plugin.AutorefsPlugin.get_item_url][]. unmapped: A list to store unmapped identifiers. Returns: The actual function accepting a [`Match` object](https://docs.python.org/3/library/re.html#match-objects) and returning the replacement strings. \"\"\" def inner ( match : Match ): # noqa: WPS212,WPS430 identifier = match [ \"identifier\" ] title = match [ \"title\" ] kind = match [ \"kind\" ] try : url = url_mapper ( unescape ( identifier )) except KeyError : if kind == \"autorefs-optional\" : return title elif kind == \"autorefs-optional-hover\" : return f '<span title=\" { identifier } \"> { title } </span>' unmapped . append ( identifier ) if title == identifier : return f \"[ { identifier } ][]\" return f \"[ { title } ][ { identifier } ]\" parsed = urlsplit ( url ) external = parsed . scheme or parsed . netloc classes = [ \"autorefs\" , \"autorefs-external\" if external else \"autorefs-internal\" ] class_attr = \" \" . join ( classes ) if kind == \"autorefs-optional-hover\" : return f '<a class=\" { class_attr } \" title=\" { identifier } \" href=\" { escape ( url ) } \"> { title } </a>' return f '<a class=\" { class_attr } \" href=\" { escape ( url ) } \"> { title } </a>' return inner fix_refs ( html , url_mapper ) \u00a4 Fix all references in the given HTML text. Parameters: Name Type Description Default html str The text to fix. required url_mapper Callable[[str], str] A callable that gets an object's site URL by its identifier, such as mkdocs_autorefs.plugin.AutorefsPlugin.get_item_url . required Returns: Type Description Tuple[str, List[str]] The fixed HTML. Source code in mkdocs_autorefs/references.py def fix_refs ( html : str , url_mapper : Callable [[ str ], str ]) -> Tuple [ str , List [ str ]]: \"\"\"Fix all references in the given HTML text. Arguments: html: The text to fix. url_mapper: A callable that gets an object's site URL by its identifier, such as [mkdocs_autorefs.plugin.AutorefsPlugin.get_item_url][]. Returns: The fixed HTML. \"\"\" unmapped = [] # type: ignore html = AUTO_REF_RE . sub ( fix_ref ( url_mapper , unmapped ), html ) return html , unmapped relative_url ( url_a , url_b ) \u00a4 Compute the relative path from URL A to URL B. Parameters: Name Type Description Default url_a str URL A. required url_b str URL B. required Returns: Type Description str The relative URL to go from A to B. Source code in mkdocs_autorefs/references.py def relative_url ( url_a : str , url_b : str ) -> str : \"\"\"Compute the relative path from URL A to URL B. Arguments: url_a: URL A. url_b: URL B. Returns: The relative URL to go from A to B. \"\"\" parts_a = url_a . split ( \"/\" ) url_b , anchor = url_b . split ( \"#\" , 1 ) parts_b = url_b . split ( \"/\" ) # remove common left parts while parts_a and parts_b and parts_a [ 0 ] == parts_b [ 0 ]: parts_a . pop ( 0 ) parts_b . pop ( 0 ) # go up as many times as remaining a parts' depth levels = len ( parts_a ) - 1 parts_relative = [ \"..\" ] * levels + parts_b # noqa: WPS435 relative = \"/\" . join ( parts_relative ) return f \" { relative } # { anchor } \"","title":"mkdocs_autorefs"},{"location":"reference/mkdocs_autorefs/#mkdocs_autorefs.plugin","text":"This module contains the \"mkdocs-autorefs\" plugin. After each page is processed by the Markdown converter, this plugin stores absolute URLs of every HTML anchors it finds to later be able to fix unresolved references. It stores them during the on_page_content event hook . Just before writing the final HTML to the disc, during the on_post_page event hook , this plugin searches for references of the form [identifier][] or [title][identifier] that were not resolved, and fixes them using the previously stored identifier-URL mapping.","title":"plugin"},{"location":"reference/mkdocs_autorefs/#mkdocs_autorefs.plugin.AutorefsPlugin","text":"An mkdocs plugin. This plugin defines the following event hooks: on_config on_page_content on_post_page Check the Developing Plugins page of mkdocs for more information about its plugin system. Source code in mkdocs_autorefs/plugin.py class AutorefsPlugin ( BasePlugin ): \"\"\"An `mkdocs` plugin. This plugin defines the following event hooks: - `on_config` - `on_page_content` - `on_post_page` Check the [Developing Plugins](https://www.mkdocs.org/user-guide/plugins/#developing-plugins) page of `mkdocs` for more information about its plugin system. \"\"\" scan_toc : bool = True current_page : Optional [ str ] = None def __init__ ( self ) -> None : \"\"\"Initialize the object.\"\"\" super () . __init__ () self . _url_map : Dict [ str , str ] = {} self . _abs_url_map : Dict [ str , str ] = {} self . get_fallback_anchor : Optional [ Callable [[ str ], Optional [ str ]]] = None # noqa: WPS234 def register_anchor ( self , page : str , identifier : str ): \"\"\"Register that an anchor corresponding to an identifier was encountered when rendering the page. Arguments: page: The relative URL of the current page. Examples: `'foo/bar/'`, `'foo/index.html'` identifier: The HTML anchor (without '#') as a string. \"\"\" self . _url_map [ identifier ] = f \" { page } # { identifier } \" def register_url ( self , identifier : str , url : str ): \"\"\"Register that the identifier should be turned into a link to this URL. Arguments: identifier: The new identifier. url: The absolute URL (including anchor, if needed) where this item can be found. \"\"\" self . _abs_url_map [ identifier ] = url def _get_item_url ( # noqa: WPS234 self , identifier : str , fallback : Optional [ Callable [[ str ], Sequence [ str ]]] = None , ) -> str : try : return self . _url_map [ identifier ] except KeyError : if identifier in self . _abs_url_map : return self . _abs_url_map [ identifier ] if fallback : new_identifiers = fallback ( identifier ) for new_identifier in new_identifiers : with contextlib . suppress ( KeyError ): url = self . _get_item_url ( new_identifier ) self . _url_map [ identifier ] = url return url raise def get_item_url ( # noqa: WPS234 self , identifier : str , from_url : Optional [ str ] = None , fallback : Optional [ Callable [[ str ], Sequence [ str ]]] = None , ) -> str : \"\"\"Return a site-relative URL with anchor to the identifier, if it's present anywhere. Arguments: identifier: The anchor (without '#'). from_url: The URL of the base page, from which we link towards the targeted pages. fallback: An optional function to suggest alternative anchors to try on failure. Returns: A site-relative URL. \"\"\" url = self . _get_item_url ( identifier , fallback ) if from_url is not None : parsed = urlsplit ( url ) if not parsed . scheme and not parsed . netloc : return relative_url ( from_url , url ) return url def on_config ( self , config : Config , ** kwargs ) -> Config : # noqa: W0613,R0201 (unused arguments, cannot be static) \"\"\"Instantiate our Markdown extension. Hook for the [`on_config` event](https://www.mkdocs.org/user-guide/plugins/#on_config). In this hook, we instantiate our [`AutorefsExtension`][mkdocs_autorefs.references.AutorefsExtension] and add it to the list of Markdown extensions used by `mkdocs`. Arguments: config: The MkDocs config object. kwargs: Additional arguments passed by MkDocs. Returns: The modified config. \"\"\" log . debug ( f \" { __name__ } : Adding AutorefsExtension to the list\" ) config [ \"markdown_extensions\" ] . append ( AutorefsExtension ()) return config def on_page_markdown ( self , markdown : str , page : Page , ** kwargs ) -> str : # noqa: W0613 (unused arguments) \"\"\"Remember which page is the current one. Arguments: markdown: Input Markdown. page: The related MkDocs page instance. kwargs: Additional arguments passed by MkDocs. Returns: The same Markdown. We only use this hook to map anchors to URLs. \"\"\" self . current_page = page . url # noqa: WPS601 return markdown def on_page_content ( self , html : str , page : Page , ** kwargs ) -> str : # noqa: W0613 (unused arguments) \"\"\"Map anchors to URLs. Hook for the [`on_page_content` event](https://www.mkdocs.org/user-guide/plugins/#on_page_content). In this hook, we map the IDs of every anchor found in the table of contents to the anchors absolute URLs. This mapping will be used later to fix unresolved reference of the form `[title][identifier]` or `[identifier][]`. Arguments: html: HTML converted from Markdown. page: The related MkDocs page instance. kwargs: Additional arguments passed by MkDocs. Returns: The same HTML. We only use this hook to map anchors to URLs. \"\"\" if self . scan_toc : log . debug ( f \" { __name__ } : Mapping identifiers to URLs for page { page . file . src_path } \" ) for item in page . toc . items : self . map_urls ( page . url , item ) return html def map_urls ( self , base_url : str , anchor : AnchorLink ) -> None : \"\"\"Recurse on every anchor to map its ID to its absolute URL. This method populates `self.url_map` by side-effect. Arguments: base_url: The base URL to use as a prefix for each anchor's relative URL. anchor: The anchor to process and to recurse on. \"\"\" self . register_anchor ( base_url , anchor . id ) for child in anchor . children : self . map_urls ( base_url , child ) def on_post_page ( self , output : str , page : Page , ** kwargs ) -> str : # noqa: W0613 (unused arguments) \"\"\"Fix cross-references. Hook for the [`on_post_page` event](https://www.mkdocs.org/user-guide/plugins/#on_post_page). In this hook, we try to fix unresolved references of the form `[title][identifier]` or `[identifier][]`. Doing that allows the user of `autorefs` to cross-reference objects in their documentation strings. It uses the native Markdown syntax so it's easy to remember and use. We log a warning for each reference that we couldn't map to an URL, but try to be smart and ignore identifiers that do not look legitimate (sometimes documentation can contain strings matching our [`AUTO_REF_RE`][mkdocs_autorefs.references.AUTO_REF_RE] regular expression that did not intend to reference anything). We currently ignore references when their identifier contains a space or a slash. Arguments: output: HTML converted from Markdown. page: The related MkDocs page instance. kwargs: Additional arguments passed by MkDocs. Returns: Modified HTML. \"\"\" log . debug ( f \" { __name__ } : Fixing references in page { page . file . src_path } \" ) url_mapper = functools . partial ( self . get_item_url , from_url = page . url , fallback = self . get_fallback_anchor ) fixed_output , unmapped = fix_refs ( output , url_mapper ) if unmapped and log . isEnabledFor ( logging . WARNING ): for ref in unmapped : log . warning ( f \" { __name__ } : { page . file . src_path } : Could not find cross-reference target '[ { ref } ]'\" , ) return fixed_output","title":"AutorefsPlugin"},{"location":"reference/mkdocs_autorefs/#mkdocs_autorefs.plugin.AutorefsPlugin.__init__","text":"Initialize the object. Source code in mkdocs_autorefs/plugin.py def __init__ ( self ) -> None : \"\"\"Initialize the object.\"\"\" super () . __init__ () self . _url_map : Dict [ str , str ] = {} self . _abs_url_map : Dict [ str , str ] = {} self . get_fallback_anchor : Optional [ Callable [[ str ], Optional [ str ]]] = None # noqa: WPS234","title":"__init__()"},{"location":"reference/mkdocs_autorefs/#mkdocs_autorefs.plugin.AutorefsPlugin.get_item_url","text":"Return a site-relative URL with anchor to the identifier, if it's present anywhere. Parameters: Name Type Description Default identifier str The anchor (without '#'). required from_url Optional[str] The URL of the base page, from which we link towards the targeted pages. None fallback Optional[Callable[[str], Sequence[str]]] An optional function to suggest alternative anchors to try on failure. None Returns: Type Description str A site-relative URL. Source code in mkdocs_autorefs/plugin.py def get_item_url ( # noqa: WPS234 self , identifier : str , from_url : Optional [ str ] = None , fallback : Optional [ Callable [[ str ], Sequence [ str ]]] = None , ) -> str : \"\"\"Return a site-relative URL with anchor to the identifier, if it's present anywhere. Arguments: identifier: The anchor (without '#'). from_url: The URL of the base page, from which we link towards the targeted pages. fallback: An optional function to suggest alternative anchors to try on failure. Returns: A site-relative URL. \"\"\" url = self . _get_item_url ( identifier , fallback ) if from_url is not None : parsed = urlsplit ( url ) if not parsed . scheme and not parsed . netloc : return relative_url ( from_url , url ) return url","title":"get_item_url()"},{"location":"reference/mkdocs_autorefs/#mkdocs_autorefs.plugin.AutorefsPlugin.map_urls","text":"Recurse on every anchor to map its ID to its absolute URL. This method populates self.url_map by side-effect. Parameters: Name Type Description Default base_url str The base URL to use as a prefix for each anchor's relative URL. required anchor AnchorLink The anchor to process and to recurse on. required Source code in mkdocs_autorefs/plugin.py def map_urls ( self , base_url : str , anchor : AnchorLink ) -> None : \"\"\"Recurse on every anchor to map its ID to its absolute URL. This method populates `self.url_map` by side-effect. Arguments: base_url: The base URL to use as a prefix for each anchor's relative URL. anchor: The anchor to process and to recurse on. \"\"\" self . register_anchor ( base_url , anchor . id ) for child in anchor . children : self . map_urls ( base_url , child )","title":"map_urls()"},{"location":"reference/mkdocs_autorefs/#mkdocs_autorefs.plugin.AutorefsPlugin.on_config","text":"Instantiate our Markdown extension. Hook for the on_config event . In this hook, we instantiate our AutorefsExtension and add it to the list of Markdown extensions used by mkdocs . Parameters: Name Type Description Default config Config The MkDocs config object. required kwargs Additional arguments passed by MkDocs. {} Returns: Type Description Config The modified config. Source code in mkdocs_autorefs/plugin.py def on_config ( self , config : Config , ** kwargs ) -> Config : # noqa: W0613,R0201 (unused arguments, cannot be static) \"\"\"Instantiate our Markdown extension. Hook for the [`on_config` event](https://www.mkdocs.org/user-guide/plugins/#on_config). In this hook, we instantiate our [`AutorefsExtension`][mkdocs_autorefs.references.AutorefsExtension] and add it to the list of Markdown extensions used by `mkdocs`. Arguments: config: The MkDocs config object. kwargs: Additional arguments passed by MkDocs. Returns: The modified config. \"\"\" log . debug ( f \" { __name__ } : Adding AutorefsExtension to the list\" ) config [ \"markdown_extensions\" ] . append ( AutorefsExtension ()) return config","title":"on_config()"},{"location":"reference/mkdocs_autorefs/#mkdocs_autorefs.plugin.AutorefsPlugin.on_page_content","text":"Map anchors to URLs. Hook for the on_page_content event . In this hook, we map the IDs of every anchor found in the table of contents to the anchors absolute URLs. This mapping will be used later to fix unresolved reference of the form [title][identifier] or [identifier][] . Parameters: Name Type Description Default html str HTML converted from Markdown. required page Page The related MkDocs page instance. required kwargs Additional arguments passed by MkDocs. {} Returns: Type Description str The same HTML. We only use this hook to map anchors to URLs. Source code in mkdocs_autorefs/plugin.py def on_page_content ( self , html : str , page : Page , ** kwargs ) -> str : # noqa: W0613 (unused arguments) \"\"\"Map anchors to URLs. Hook for the [`on_page_content` event](https://www.mkdocs.org/user-guide/plugins/#on_page_content). In this hook, we map the IDs of every anchor found in the table of contents to the anchors absolute URLs. This mapping will be used later to fix unresolved reference of the form `[title][identifier]` or `[identifier][]`. Arguments: html: HTML converted from Markdown. page: The related MkDocs page instance. kwargs: Additional arguments passed by MkDocs. Returns: The same HTML. We only use this hook to map anchors to URLs. \"\"\" if self . scan_toc : log . debug ( f \" { __name__ } : Mapping identifiers to URLs for page { page . file . src_path } \" ) for item in page . toc . items : self . map_urls ( page . url , item ) return html","title":"on_page_content()"},{"location":"reference/mkdocs_autorefs/#mkdocs_autorefs.plugin.AutorefsPlugin.on_page_markdown","text":"Remember which page is the current one. Parameters: Name Type Description Default markdown str Input Markdown. required page Page The related MkDocs page instance. required kwargs Additional arguments passed by MkDocs. {} Returns: Type Description str The same Markdown. We only use this hook to map anchors to URLs. Source code in mkdocs_autorefs/plugin.py def on_page_markdown ( self , markdown : str , page : Page , ** kwargs ) -> str : # noqa: W0613 (unused arguments) \"\"\"Remember which page is the current one. Arguments: markdown: Input Markdown. page: The related MkDocs page instance. kwargs: Additional arguments passed by MkDocs. Returns: The same Markdown. We only use this hook to map anchors to URLs. \"\"\" self . current_page = page . url # noqa: WPS601 return markdown","title":"on_page_markdown()"},{"location":"reference/mkdocs_autorefs/#mkdocs_autorefs.plugin.AutorefsPlugin.on_post_page","text":"Fix cross-references. Hook for the on_post_page event . In this hook, we try to fix unresolved references of the form [title][identifier] or [identifier][] . Doing that allows the user of autorefs to cross-reference objects in their documentation strings. It uses the native Markdown syntax so it's easy to remember and use. We log a warning for each reference that we couldn't map to an URL, but try to be smart and ignore identifiers that do not look legitimate (sometimes documentation can contain strings matching our AUTO_REF_RE regular expression that did not intend to reference anything). We currently ignore references when their identifier contains a space or a slash. Parameters: Name Type Description Default output str HTML converted from Markdown. required page Page The related MkDocs page instance. required kwargs Additional arguments passed by MkDocs. {} Returns: Type Description str Modified HTML. Source code in mkdocs_autorefs/plugin.py def on_post_page ( self , output : str , page : Page , ** kwargs ) -> str : # noqa: W0613 (unused arguments) \"\"\"Fix cross-references. Hook for the [`on_post_page` event](https://www.mkdocs.org/user-guide/plugins/#on_post_page). In this hook, we try to fix unresolved references of the form `[title][identifier]` or `[identifier][]`. Doing that allows the user of `autorefs` to cross-reference objects in their documentation strings. It uses the native Markdown syntax so it's easy to remember and use. We log a warning for each reference that we couldn't map to an URL, but try to be smart and ignore identifiers that do not look legitimate (sometimes documentation can contain strings matching our [`AUTO_REF_RE`][mkdocs_autorefs.references.AUTO_REF_RE] regular expression that did not intend to reference anything). We currently ignore references when their identifier contains a space or a slash. Arguments: output: HTML converted from Markdown. page: The related MkDocs page instance. kwargs: Additional arguments passed by MkDocs. Returns: Modified HTML. \"\"\" log . debug ( f \" { __name__ } : Fixing references in page { page . file . src_path } \" ) url_mapper = functools . partial ( self . get_item_url , from_url = page . url , fallback = self . get_fallback_anchor ) fixed_output , unmapped = fix_refs ( output , url_mapper ) if unmapped and log . isEnabledFor ( logging . WARNING ): for ref in unmapped : log . warning ( f \" { __name__ } : { page . file . src_path } : Could not find cross-reference target '[ { ref } ]'\" , ) return fixed_output","title":"on_post_page()"},{"location":"reference/mkdocs_autorefs/#mkdocs_autorefs.plugin.AutorefsPlugin.register_anchor","text":"Register that an anchor corresponding to an identifier was encountered when rendering the page. Parameters: Name Type Description Default page str The relative URL of the current page. Examples: 'foo/bar/' , 'foo/index.html' required identifier str The HTML anchor (without '#') as a string. required Source code in mkdocs_autorefs/plugin.py def register_anchor ( self , page : str , identifier : str ): \"\"\"Register that an anchor corresponding to an identifier was encountered when rendering the page. Arguments: page: The relative URL of the current page. Examples: `'foo/bar/'`, `'foo/index.html'` identifier: The HTML anchor (without '#') as a string. \"\"\" self . _url_map [ identifier ] = f \" { page } # { identifier } \"","title":"register_anchor()"},{"location":"reference/mkdocs_autorefs/#mkdocs_autorefs.plugin.AutorefsPlugin.register_url","text":"Register that the identifier should be turned into a link to this URL. Parameters: Name Type Description Default identifier str The new identifier. required url str The absolute URL (including anchor, if needed) where this item can be found. required Source code in mkdocs_autorefs/plugin.py def register_url ( self , identifier : str , url : str ): \"\"\"Register that the identifier should be turned into a link to this URL. Arguments: identifier: The new identifier. url: The absolute URL (including anchor, if needed) where this item can be found. \"\"\" self . _abs_url_map [ identifier ] = url","title":"register_url()"},{"location":"reference/mkdocs_autorefs/#mkdocs_autorefs.references","text":"Cross-references module.","title":"references"},{"location":"reference/mkdocs_autorefs/#mkdocs_autorefs.references.AUTO_REF_RE","text":"A regular expression to match mkdocs-autorefs' special reference markers in the on_post_page hook .","title":"AUTO_REF_RE"},{"location":"reference/mkdocs_autorefs/#mkdocs_autorefs.references.AutoRefInlineProcessor","text":"A Markdown extension. Source code in mkdocs_autorefs/references.py class AutoRefInlineProcessor ( ReferenceInlineProcessor ): \"\"\"A Markdown extension.\"\"\" def __init__ ( self , * args , ** kwargs ): # noqa: D107 super () . __init__ ( REFERENCE_RE , * args , ** kwargs ) # Code based on # https://github.com/Python-Markdown/markdown/blob/8e7528fa5c98bf4652deb13206d6e6241d61630b/markdown/inlinepatterns.py#L780 def handleMatch ( self , m , data ) -> Union [ Element , EvalIDType ]: # type: ignore[override] # noqa: N802,WPS111 \"\"\"Handle an element that matched. Arguments: m: The match object. data: The matched data. Returns: A new element or a tuple. \"\"\" text , index , handled = self . getText ( data , m . end ( 0 )) if not handled : return None , None , None identifier , end , handled = self . evalId ( data , index , text ) if not handled : return None , None , None if re . search ( r \"[/ \\x00-\\x1f]\" , identifier ): # Do nothing if the matched reference contains: # - a space, slash or control character (considered unintended); # - specifically \\x01 is used by Python-Markdown HTML stash when there's inline formatting, # but references with Markdown formatting are not possible anyway. return None , m . start ( 0 ), end return self . makeTag ( identifier , text ), m . start ( 0 ), end def evalId ( self , data : str , index : int , text : str ) -> EvalIDType : # noqa: N802 (parent's casing) \"\"\"Evaluate the id portion of `[ref][id]`. If `[ref][]` use `[ref]`. Arguments: data: The data to evaluate. index: The starting position. text: The text to use when no identifier. Returns: A tuple containing the identifier, its end position, and whether it matched. \"\"\" m = self . RE_LINK . match ( data , pos = index ) # noqa: WPS111 if not m : return None , index , False identifier = m . group ( 1 ) if not identifier : identifier = text # Allow the entire content to be one placeholder, with the intent of catching things like [`Foo`][]. # It doesn't catch [*Foo*][] though, just due to the priority order. # https://github.com/Python-Markdown/markdown/blob/1858c1b601ead62ed49646ae0d99298f41b1a271/markdown/inlinepatterns.py#L78 if INLINE_PLACEHOLDER_RE . fullmatch ( identifier ): identifier = self . unescape ( identifier ) end = m . end ( 0 ) return identifier , end , True def makeTag ( self , identifier : str , text : str ) -> Element : # type: ignore[override] # noqa: N802,W0221 \"\"\"Create a tag that can be matched by `AUTO_REF_RE`. Arguments: identifier: The identifier to use in the HTML property. text: The text to use in the HTML tag. Returns: A new element. \"\"\" el = Element ( \"span\" ) el . set ( \"data-autorefs-identifier\" , identifier ) el . text = text return el","title":"AutoRefInlineProcessor"},{"location":"reference/mkdocs_autorefs/#mkdocs_autorefs.references.AutoRefInlineProcessor.evalId","text":"Evaluate the id portion of [ref][id] . If [ref][] use [ref] . Parameters: Name Type Description Default data str The data to evaluate. required index int The starting position. required text str The text to use when no identifier. required Returns: Type Description Tuple[Any, Any, Any] A tuple containing the identifier, its end position, and whether it matched. Source code in mkdocs_autorefs/references.py def evalId ( self , data : str , index : int , text : str ) -> EvalIDType : # noqa: N802 (parent's casing) \"\"\"Evaluate the id portion of `[ref][id]`. If `[ref][]` use `[ref]`. Arguments: data: The data to evaluate. index: The starting position. text: The text to use when no identifier. Returns: A tuple containing the identifier, its end position, and whether it matched. \"\"\" m = self . RE_LINK . match ( data , pos = index ) # noqa: WPS111 if not m : return None , index , False identifier = m . group ( 1 ) if not identifier : identifier = text # Allow the entire content to be one placeholder, with the intent of catching things like [`Foo`][]. # It doesn't catch [*Foo*][] though, just due to the priority order. # https://github.com/Python-Markdown/markdown/blob/1858c1b601ead62ed49646ae0d99298f41b1a271/markdown/inlinepatterns.py#L78 if INLINE_PLACEHOLDER_RE . fullmatch ( identifier ): identifier = self . unescape ( identifier ) end = m . end ( 0 ) return identifier , end , True","title":"evalId()"},{"location":"reference/mkdocs_autorefs/#mkdocs_autorefs.references.AutoRefInlineProcessor.handleMatch","text":"Handle an element that matched. Parameters: Name Type Description Default m The match object. required data The matched data. required Returns: Type Description Union[xml.etree.ElementTree.Element, Tuple[Any, Any, Any]] A new element or a tuple. Source code in mkdocs_autorefs/references.py def handleMatch ( self , m , data ) -> Union [ Element , EvalIDType ]: # type: ignore[override] # noqa: N802,WPS111 \"\"\"Handle an element that matched. Arguments: m: The match object. data: The matched data. Returns: A new element or a tuple. \"\"\" text , index , handled = self . getText ( data , m . end ( 0 )) if not handled : return None , None , None identifier , end , handled = self . evalId ( data , index , text ) if not handled : return None , None , None if re . search ( r \"[/ \\x00-\\x1f]\" , identifier ): # Do nothing if the matched reference contains: # - a space, slash or control character (considered unintended); # - specifically \\x01 is used by Python-Markdown HTML stash when there's inline formatting, # but references with Markdown formatting are not possible anyway. return None , m . start ( 0 ), end return self . makeTag ( identifier , text ), m . start ( 0 ), end","title":"handleMatch()"},{"location":"reference/mkdocs_autorefs/#mkdocs_autorefs.references.AutoRefInlineProcessor.makeTag","text":"Create a tag that can be matched by AUTO_REF_RE . Parameters: Name Type Description Default identifier str The identifier to use in the HTML property. required text str The text to use in the HTML tag. required Returns: Type Description Element A new element. Source code in mkdocs_autorefs/references.py def makeTag ( self , identifier : str , text : str ) -> Element : # type: ignore[override] # noqa: N802,W0221 \"\"\"Create a tag that can be matched by `AUTO_REF_RE`. Arguments: identifier: The identifier to use in the HTML property. text: The text to use in the HTML tag. Returns: A new element. \"\"\" el = Element ( \"span\" ) el . set ( \"data-autorefs-identifier\" , identifier ) el . text = text return el","title":"makeTag()"},{"location":"reference/mkdocs_autorefs/#mkdocs_autorefs.references.AutorefsExtension","text":"Extension that inserts auto-references in Markdown. Source code in mkdocs_autorefs/references.py class AutorefsExtension ( Extension ): \"\"\"Extension that inserts auto-references in Markdown.\"\"\" def extendMarkdown ( self , md : Markdown ) -> None : # noqa: N802 (casing: parent method's name) \"\"\"Register the extension. Add an instance of our [`AutoRefInlineProcessor`][mkdocs_autorefs.references.AutoRefInlineProcessor] to the Markdown parser. Arguments: md: A `markdown.Markdown` instance. \"\"\" md . inlinePatterns . register ( AutoRefInlineProcessor ( md ), \"mkdocs-autorefs\" , priority = 168 , # noqa: WPS432 # Right after markdown.inlinepatterns.ReferenceInlineProcessor )","title":"AutorefsExtension"},{"location":"reference/mkdocs_autorefs/#mkdocs_autorefs.references.AutorefsExtension.extendMarkdown","text":"Register the extension. Add an instance of our AutoRefInlineProcessor to the Markdown parser. Parameters: Name Type Description Default md Markdown A markdown.Markdown instance. required Source code in mkdocs_autorefs/references.py def extendMarkdown ( self , md : Markdown ) -> None : # noqa: N802 (casing: parent method's name) \"\"\"Register the extension. Add an instance of our [`AutoRefInlineProcessor`][mkdocs_autorefs.references.AutoRefInlineProcessor] to the Markdown parser. Arguments: md: A `markdown.Markdown` instance. \"\"\" md . inlinePatterns . register ( AutoRefInlineProcessor ( md ), \"mkdocs-autorefs\" , priority = 168 , # noqa: WPS432 # Right after markdown.inlinepatterns.ReferenceInlineProcessor )","title":"extendMarkdown()"},{"location":"reference/mkdocs_autorefs/#mkdocs_autorefs.references.fix_ref","text":"Return a repl function for re.sub . In our context, we match Markdown references and replace them with HTML links. When the matched reference's identifier was not mapped to an URL, we append the identifier to the outer unmapped list. It generally means the user is trying to cross-reference an object that was not collected and rendered, making it impossible to link to it. We catch this exception in the caller to issue a warning. Parameters: Name Type Description Default url_mapper Callable[[str], str] A callable that gets an object's site URL by its identifier, such as mkdocs_autorefs.plugin.AutorefsPlugin.get_item_url . required unmapped List[str] A list to store unmapped identifiers. required Returns: Type Description The actual function accepting a [`Match` object](https //docs.python.org/3/library/re.html#match-objects) and returning the replacement strings. Source code in mkdocs_autorefs/references.py def fix_ref ( url_mapper : Callable [[ str ], str ], unmapped : List [ str ]) -> Callable : # noqa: WPS212,WPS231 \"\"\"Return a `repl` function for [`re.sub`](https://docs.python.org/3/library/re.html#re.sub). In our context, we match Markdown references and replace them with HTML links. When the matched reference's identifier was not mapped to an URL, we append the identifier to the outer `unmapped` list. It generally means the user is trying to cross-reference an object that was not collected and rendered, making it impossible to link to it. We catch this exception in the caller to issue a warning. Arguments: url_mapper: A callable that gets an object's site URL by its identifier, such as [mkdocs_autorefs.plugin.AutorefsPlugin.get_item_url][]. unmapped: A list to store unmapped identifiers. Returns: The actual function accepting a [`Match` object](https://docs.python.org/3/library/re.html#match-objects) and returning the replacement strings. \"\"\" def inner ( match : Match ): # noqa: WPS212,WPS430 identifier = match [ \"identifier\" ] title = match [ \"title\" ] kind = match [ \"kind\" ] try : url = url_mapper ( unescape ( identifier )) except KeyError : if kind == \"autorefs-optional\" : return title elif kind == \"autorefs-optional-hover\" : return f '<span title=\" { identifier } \"> { title } </span>' unmapped . append ( identifier ) if title == identifier : return f \"[ { identifier } ][]\" return f \"[ { title } ][ { identifier } ]\" parsed = urlsplit ( url ) external = parsed . scheme or parsed . netloc classes = [ \"autorefs\" , \"autorefs-external\" if external else \"autorefs-internal\" ] class_attr = \" \" . join ( classes ) if kind == \"autorefs-optional-hover\" : return f '<a class=\" { class_attr } \" title=\" { identifier } \" href=\" { escape ( url ) } \"> { title } </a>' return f '<a class=\" { class_attr } \" href=\" { escape ( url ) } \"> { title } </a>' return inner","title":"fix_ref()"},{"location":"reference/mkdocs_autorefs/#mkdocs_autorefs.references.fix_refs","text":"Fix all references in the given HTML text. Parameters: Name Type Description Default html str The text to fix. required url_mapper Callable[[str], str] A callable that gets an object's site URL by its identifier, such as mkdocs_autorefs.plugin.AutorefsPlugin.get_item_url . required Returns: Type Description Tuple[str, List[str]] The fixed HTML. Source code in mkdocs_autorefs/references.py def fix_refs ( html : str , url_mapper : Callable [[ str ], str ]) -> Tuple [ str , List [ str ]]: \"\"\"Fix all references in the given HTML text. Arguments: html: The text to fix. url_mapper: A callable that gets an object's site URL by its identifier, such as [mkdocs_autorefs.plugin.AutorefsPlugin.get_item_url][]. Returns: The fixed HTML. \"\"\" unmapped = [] # type: ignore html = AUTO_REF_RE . sub ( fix_ref ( url_mapper , unmapped ), html ) return html , unmapped","title":"fix_refs()"},{"location":"reference/mkdocs_autorefs/#mkdocs_autorefs.references.relative_url","text":"Compute the relative path from URL A to URL B. Parameters: Name Type Description Default url_a str URL A. required url_b str URL B. required Returns: Type Description str The relative URL to go from A to B. Source code in mkdocs_autorefs/references.py def relative_url ( url_a : str , url_b : str ) -> str : \"\"\"Compute the relative path from URL A to URL B. Arguments: url_a: URL A. url_b: URL B. Returns: The relative URL to go from A to B. \"\"\" parts_a = url_a . split ( \"/\" ) url_b , anchor = url_b . split ( \"#\" , 1 ) parts_b = url_b . split ( \"/\" ) # remove common left parts while parts_a and parts_b and parts_a [ 0 ] == parts_b [ 0 ]: parts_a . pop ( 0 ) parts_b . pop ( 0 ) # go up as many times as remaining a parts' depth levels = len ( parts_a ) - 1 parts_relative = [ \"..\" ] * levels + parts_b # noqa: WPS435 relative = \"/\" . join ( parts_relative ) return f \" { relative } # { anchor } \"","title":"relative_url()"},{"location":"reference/mkdocs_autorefs/plugin/","text":"This module contains the \"mkdocs-autorefs\" plugin. After each page is processed by the Markdown converter, this plugin stores absolute URLs of every HTML anchors it finds to later be able to fix unresolved references. It stores them during the on_page_content event hook . Just before writing the final HTML to the disc, during the on_post_page event hook , this plugin searches for references of the form [identifier][] or [title][identifier] that were not resolved, and fixes them using the previously stored identifier-URL mapping. AutorefsPlugin ( BasePlugin ) \u00a4 An mkdocs plugin. This plugin defines the following event hooks: on_config on_page_content on_post_page Check the Developing Plugins page of mkdocs for more information about its plugin system. Source code in mkdocs_autorefs/plugin.py class AutorefsPlugin ( BasePlugin ): \"\"\"An `mkdocs` plugin. This plugin defines the following event hooks: - `on_config` - `on_page_content` - `on_post_page` Check the [Developing Plugins](https://www.mkdocs.org/user-guide/plugins/#developing-plugins) page of `mkdocs` for more information about its plugin system. \"\"\" scan_toc : bool = True current_page : Optional [ str ] = None def __init__ ( self ) -> None : \"\"\"Initialize the object.\"\"\" super () . __init__ () self . _url_map : Dict [ str , str ] = {} self . _abs_url_map : Dict [ str , str ] = {} self . get_fallback_anchor : Optional [ Callable [[ str ], Optional [ str ]]] = None # noqa: WPS234 def register_anchor ( self , page : str , identifier : str ): \"\"\"Register that an anchor corresponding to an identifier was encountered when rendering the page. Arguments: page: The relative URL of the current page. Examples: `'foo/bar/'`, `'foo/index.html'` identifier: The HTML anchor (without '#') as a string. \"\"\" self . _url_map [ identifier ] = f \" { page } # { identifier } \" def register_url ( self , identifier : str , url : str ): \"\"\"Register that the identifier should be turned into a link to this URL. Arguments: identifier: The new identifier. url: The absolute URL (including anchor, if needed) where this item can be found. \"\"\" self . _abs_url_map [ identifier ] = url def _get_item_url ( # noqa: WPS234 self , identifier : str , fallback : Optional [ Callable [[ str ], Sequence [ str ]]] = None , ) -> str : try : return self . _url_map [ identifier ] except KeyError : if identifier in self . _abs_url_map : return self . _abs_url_map [ identifier ] if fallback : new_identifiers = fallback ( identifier ) for new_identifier in new_identifiers : with contextlib . suppress ( KeyError ): url = self . _get_item_url ( new_identifier ) self . _url_map [ identifier ] = url return url raise def get_item_url ( # noqa: WPS234 self , identifier : str , from_url : Optional [ str ] = None , fallback : Optional [ Callable [[ str ], Sequence [ str ]]] = None , ) -> str : \"\"\"Return a site-relative URL with anchor to the identifier, if it's present anywhere. Arguments: identifier: The anchor (without '#'). from_url: The URL of the base page, from which we link towards the targeted pages. fallback: An optional function to suggest alternative anchors to try on failure. Returns: A site-relative URL. \"\"\" url = self . _get_item_url ( identifier , fallback ) if from_url is not None : parsed = urlsplit ( url ) if not parsed . scheme and not parsed . netloc : return relative_url ( from_url , url ) return url def on_config ( self , config : Config , ** kwargs ) -> Config : # noqa: W0613,R0201 (unused arguments, cannot be static) \"\"\"Instantiate our Markdown extension. Hook for the [`on_config` event](https://www.mkdocs.org/user-guide/plugins/#on_config). In this hook, we instantiate our [`AutorefsExtension`][mkdocs_autorefs.references.AutorefsExtension] and add it to the list of Markdown extensions used by `mkdocs`. Arguments: config: The MkDocs config object. kwargs: Additional arguments passed by MkDocs. Returns: The modified config. \"\"\" log . debug ( f \" { __name__ } : Adding AutorefsExtension to the list\" ) config [ \"markdown_extensions\" ] . append ( AutorefsExtension ()) return config def on_page_markdown ( self , markdown : str , page : Page , ** kwargs ) -> str : # noqa: W0613 (unused arguments) \"\"\"Remember which page is the current one. Arguments: markdown: Input Markdown. page: The related MkDocs page instance. kwargs: Additional arguments passed by MkDocs. Returns: The same Markdown. We only use this hook to map anchors to URLs. \"\"\" self . current_page = page . url # noqa: WPS601 return markdown def on_page_content ( self , html : str , page : Page , ** kwargs ) -> str : # noqa: W0613 (unused arguments) \"\"\"Map anchors to URLs. Hook for the [`on_page_content` event](https://www.mkdocs.org/user-guide/plugins/#on_page_content). In this hook, we map the IDs of every anchor found in the table of contents to the anchors absolute URLs. This mapping will be used later to fix unresolved reference of the form `[title][identifier]` or `[identifier][]`. Arguments: html: HTML converted from Markdown. page: The related MkDocs page instance. kwargs: Additional arguments passed by MkDocs. Returns: The same HTML. We only use this hook to map anchors to URLs. \"\"\" if self . scan_toc : log . debug ( f \" { __name__ } : Mapping identifiers to URLs for page { page . file . src_path } \" ) for item in page . toc . items : self . map_urls ( page . url , item ) return html def map_urls ( self , base_url : str , anchor : AnchorLink ) -> None : \"\"\"Recurse on every anchor to map its ID to its absolute URL. This method populates `self.url_map` by side-effect. Arguments: base_url: The base URL to use as a prefix for each anchor's relative URL. anchor: The anchor to process and to recurse on. \"\"\" self . register_anchor ( base_url , anchor . id ) for child in anchor . children : self . map_urls ( base_url , child ) def on_post_page ( self , output : str , page : Page , ** kwargs ) -> str : # noqa: W0613 (unused arguments) \"\"\"Fix cross-references. Hook for the [`on_post_page` event](https://www.mkdocs.org/user-guide/plugins/#on_post_page). In this hook, we try to fix unresolved references of the form `[title][identifier]` or `[identifier][]`. Doing that allows the user of `autorefs` to cross-reference objects in their documentation strings. It uses the native Markdown syntax so it's easy to remember and use. We log a warning for each reference that we couldn't map to an URL, but try to be smart and ignore identifiers that do not look legitimate (sometimes documentation can contain strings matching our [`AUTO_REF_RE`][mkdocs_autorefs.references.AUTO_REF_RE] regular expression that did not intend to reference anything). We currently ignore references when their identifier contains a space or a slash. Arguments: output: HTML converted from Markdown. page: The related MkDocs page instance. kwargs: Additional arguments passed by MkDocs. Returns: Modified HTML. \"\"\" log . debug ( f \" { __name__ } : Fixing references in page { page . file . src_path } \" ) url_mapper = functools . partial ( self . get_item_url , from_url = page . url , fallback = self . get_fallback_anchor ) fixed_output , unmapped = fix_refs ( output , url_mapper ) if unmapped and log . isEnabledFor ( logging . WARNING ): for ref in unmapped : log . warning ( f \" { __name__ } : { page . file . src_path } : Could not find cross-reference target '[ { ref } ]'\" , ) return fixed_output __init__ ( self ) special \u00a4 Initialize the object. Source code in mkdocs_autorefs/plugin.py def __init__ ( self ) -> None : \"\"\"Initialize the object.\"\"\" super () . __init__ () self . _url_map : Dict [ str , str ] = {} self . _abs_url_map : Dict [ str , str ] = {} self . get_fallback_anchor : Optional [ Callable [[ str ], Optional [ str ]]] = None # noqa: WPS234 get_item_url ( self , identifier , from_url = None , fallback = None ) \u00a4 Return a site-relative URL with anchor to the identifier, if it's present anywhere. Parameters: Name Type Description Default identifier str The anchor (without '#'). required from_url Optional[str] The URL of the base page, from which we link towards the targeted pages. None fallback Optional[Callable[[str], Sequence[str]]] An optional function to suggest alternative anchors to try on failure. None Returns: Type Description str A site-relative URL. Source code in mkdocs_autorefs/plugin.py def get_item_url ( # noqa: WPS234 self , identifier : str , from_url : Optional [ str ] = None , fallback : Optional [ Callable [[ str ], Sequence [ str ]]] = None , ) -> str : \"\"\"Return a site-relative URL with anchor to the identifier, if it's present anywhere. Arguments: identifier: The anchor (without '#'). from_url: The URL of the base page, from which we link towards the targeted pages. fallback: An optional function to suggest alternative anchors to try on failure. Returns: A site-relative URL. \"\"\" url = self . _get_item_url ( identifier , fallback ) if from_url is not None : parsed = urlsplit ( url ) if not parsed . scheme and not parsed . netloc : return relative_url ( from_url , url ) return url map_urls ( self , base_url , anchor ) \u00a4 Recurse on every anchor to map its ID to its absolute URL. This method populates self.url_map by side-effect. Parameters: Name Type Description Default base_url str The base URL to use as a prefix for each anchor's relative URL. required anchor AnchorLink The anchor to process and to recurse on. required Source code in mkdocs_autorefs/plugin.py def map_urls ( self , base_url : str , anchor : AnchorLink ) -> None : \"\"\"Recurse on every anchor to map its ID to its absolute URL. This method populates `self.url_map` by side-effect. Arguments: base_url: The base URL to use as a prefix for each anchor's relative URL. anchor: The anchor to process and to recurse on. \"\"\" self . register_anchor ( base_url , anchor . id ) for child in anchor . children : self . map_urls ( base_url , child ) on_config ( self , config , ** kwargs ) \u00a4 Instantiate our Markdown extension. Hook for the on_config event . In this hook, we instantiate our AutorefsExtension and add it to the list of Markdown extensions used by mkdocs . Parameters: Name Type Description Default config Config The MkDocs config object. required kwargs Additional arguments passed by MkDocs. {} Returns: Type Description Config The modified config. Source code in mkdocs_autorefs/plugin.py def on_config ( self , config : Config , ** kwargs ) -> Config : # noqa: W0613,R0201 (unused arguments, cannot be static) \"\"\"Instantiate our Markdown extension. Hook for the [`on_config` event](https://www.mkdocs.org/user-guide/plugins/#on_config). In this hook, we instantiate our [`AutorefsExtension`][mkdocs_autorefs.references.AutorefsExtension] and add it to the list of Markdown extensions used by `mkdocs`. Arguments: config: The MkDocs config object. kwargs: Additional arguments passed by MkDocs. Returns: The modified config. \"\"\" log . debug ( f \" { __name__ } : Adding AutorefsExtension to the list\" ) config [ \"markdown_extensions\" ] . append ( AutorefsExtension ()) return config on_page_content ( self , html , page , ** kwargs ) \u00a4 Map anchors to URLs. Hook for the on_page_content event . In this hook, we map the IDs of every anchor found in the table of contents to the anchors absolute URLs. This mapping will be used later to fix unresolved reference of the form [title][identifier] or [identifier][] . Parameters: Name Type Description Default html str HTML converted from Markdown. required page Page The related MkDocs page instance. required kwargs Additional arguments passed by MkDocs. {} Returns: Type Description str The same HTML. We only use this hook to map anchors to URLs. Source code in mkdocs_autorefs/plugin.py def on_page_content ( self , html : str , page : Page , ** kwargs ) -> str : # noqa: W0613 (unused arguments) \"\"\"Map anchors to URLs. Hook for the [`on_page_content` event](https://www.mkdocs.org/user-guide/plugins/#on_page_content). In this hook, we map the IDs of every anchor found in the table of contents to the anchors absolute URLs. This mapping will be used later to fix unresolved reference of the form `[title][identifier]` or `[identifier][]`. Arguments: html: HTML converted from Markdown. page: The related MkDocs page instance. kwargs: Additional arguments passed by MkDocs. Returns: The same HTML. We only use this hook to map anchors to URLs. \"\"\" if self . scan_toc : log . debug ( f \" { __name__ } : Mapping identifiers to URLs for page { page . file . src_path } \" ) for item in page . toc . items : self . map_urls ( page . url , item ) return html on_page_markdown ( self , markdown , page , ** kwargs ) \u00a4 Remember which page is the current one. Parameters: Name Type Description Default markdown str Input Markdown. required page Page The related MkDocs page instance. required kwargs Additional arguments passed by MkDocs. {} Returns: Type Description str The same Markdown. We only use this hook to map anchors to URLs. Source code in mkdocs_autorefs/plugin.py def on_page_markdown ( self , markdown : str , page : Page , ** kwargs ) -> str : # noqa: W0613 (unused arguments) \"\"\"Remember which page is the current one. Arguments: markdown: Input Markdown. page: The related MkDocs page instance. kwargs: Additional arguments passed by MkDocs. Returns: The same Markdown. We only use this hook to map anchors to URLs. \"\"\" self . current_page = page . url # noqa: WPS601 return markdown on_post_page ( self , output , page , ** kwargs ) \u00a4 Fix cross-references. Hook for the on_post_page event . In this hook, we try to fix unresolved references of the form [title][identifier] or [identifier][] . Doing that allows the user of autorefs to cross-reference objects in their documentation strings. It uses the native Markdown syntax so it's easy to remember and use. We log a warning for each reference that we couldn't map to an URL, but try to be smart and ignore identifiers that do not look legitimate (sometimes documentation can contain strings matching our AUTO_REF_RE regular expression that did not intend to reference anything). We currently ignore references when their identifier contains a space or a slash. Parameters: Name Type Description Default output str HTML converted from Markdown. required page Page The related MkDocs page instance. required kwargs Additional arguments passed by MkDocs. {} Returns: Type Description str Modified HTML. Source code in mkdocs_autorefs/plugin.py def on_post_page ( self , output : str , page : Page , ** kwargs ) -> str : # noqa: W0613 (unused arguments) \"\"\"Fix cross-references. Hook for the [`on_post_page` event](https://www.mkdocs.org/user-guide/plugins/#on_post_page). In this hook, we try to fix unresolved references of the form `[title][identifier]` or `[identifier][]`. Doing that allows the user of `autorefs` to cross-reference objects in their documentation strings. It uses the native Markdown syntax so it's easy to remember and use. We log a warning for each reference that we couldn't map to an URL, but try to be smart and ignore identifiers that do not look legitimate (sometimes documentation can contain strings matching our [`AUTO_REF_RE`][mkdocs_autorefs.references.AUTO_REF_RE] regular expression that did not intend to reference anything). We currently ignore references when their identifier contains a space or a slash. Arguments: output: HTML converted from Markdown. page: The related MkDocs page instance. kwargs: Additional arguments passed by MkDocs. Returns: Modified HTML. \"\"\" log . debug ( f \" { __name__ } : Fixing references in page { page . file . src_path } \" ) url_mapper = functools . partial ( self . get_item_url , from_url = page . url , fallback = self . get_fallback_anchor ) fixed_output , unmapped = fix_refs ( output , url_mapper ) if unmapped and log . isEnabledFor ( logging . WARNING ): for ref in unmapped : log . warning ( f \" { __name__ } : { page . file . src_path } : Could not find cross-reference target '[ { ref } ]'\" , ) return fixed_output register_anchor ( self , page , identifier ) \u00a4 Register that an anchor corresponding to an identifier was encountered when rendering the page. Parameters: Name Type Description Default page str The relative URL of the current page. Examples: 'foo/bar/' , 'foo/index.html' required identifier str The HTML anchor (without '#') as a string. required Source code in mkdocs_autorefs/plugin.py def register_anchor ( self , page : str , identifier : str ): \"\"\"Register that an anchor corresponding to an identifier was encountered when rendering the page. Arguments: page: The relative URL of the current page. Examples: `'foo/bar/'`, `'foo/index.html'` identifier: The HTML anchor (without '#') as a string. \"\"\" self . _url_map [ identifier ] = f \" { page } # { identifier } \" register_url ( self , identifier , url ) \u00a4 Register that the identifier should be turned into a link to this URL. Parameters: Name Type Description Default identifier str The new identifier. required url str The absolute URL (including anchor, if needed) where this item can be found. required Source code in mkdocs_autorefs/plugin.py def register_url ( self , identifier : str , url : str ): \"\"\"Register that the identifier should be turned into a link to this URL. Arguments: identifier: The new identifier. url: The absolute URL (including anchor, if needed) where this item can be found. \"\"\" self . _abs_url_map [ identifier ] = url","title":"plugin"},{"location":"reference/mkdocs_autorefs/plugin/#mkdocs_autorefs.plugin.AutorefsPlugin","text":"An mkdocs plugin. This plugin defines the following event hooks: on_config on_page_content on_post_page Check the Developing Plugins page of mkdocs for more information about its plugin system. Source code in mkdocs_autorefs/plugin.py class AutorefsPlugin ( BasePlugin ): \"\"\"An `mkdocs` plugin. This plugin defines the following event hooks: - `on_config` - `on_page_content` - `on_post_page` Check the [Developing Plugins](https://www.mkdocs.org/user-guide/plugins/#developing-plugins) page of `mkdocs` for more information about its plugin system. \"\"\" scan_toc : bool = True current_page : Optional [ str ] = None def __init__ ( self ) -> None : \"\"\"Initialize the object.\"\"\" super () . __init__ () self . _url_map : Dict [ str , str ] = {} self . _abs_url_map : Dict [ str , str ] = {} self . get_fallback_anchor : Optional [ Callable [[ str ], Optional [ str ]]] = None # noqa: WPS234 def register_anchor ( self , page : str , identifier : str ): \"\"\"Register that an anchor corresponding to an identifier was encountered when rendering the page. Arguments: page: The relative URL of the current page. Examples: `'foo/bar/'`, `'foo/index.html'` identifier: The HTML anchor (without '#') as a string. \"\"\" self . _url_map [ identifier ] = f \" { page } # { identifier } \" def register_url ( self , identifier : str , url : str ): \"\"\"Register that the identifier should be turned into a link to this URL. Arguments: identifier: The new identifier. url: The absolute URL (including anchor, if needed) where this item can be found. \"\"\" self . _abs_url_map [ identifier ] = url def _get_item_url ( # noqa: WPS234 self , identifier : str , fallback : Optional [ Callable [[ str ], Sequence [ str ]]] = None , ) -> str : try : return self . _url_map [ identifier ] except KeyError : if identifier in self . _abs_url_map : return self . _abs_url_map [ identifier ] if fallback : new_identifiers = fallback ( identifier ) for new_identifier in new_identifiers : with contextlib . suppress ( KeyError ): url = self . _get_item_url ( new_identifier ) self . _url_map [ identifier ] = url return url raise def get_item_url ( # noqa: WPS234 self , identifier : str , from_url : Optional [ str ] = None , fallback : Optional [ Callable [[ str ], Sequence [ str ]]] = None , ) -> str : \"\"\"Return a site-relative URL with anchor to the identifier, if it's present anywhere. Arguments: identifier: The anchor (without '#'). from_url: The URL of the base page, from which we link towards the targeted pages. fallback: An optional function to suggest alternative anchors to try on failure. Returns: A site-relative URL. \"\"\" url = self . _get_item_url ( identifier , fallback ) if from_url is not None : parsed = urlsplit ( url ) if not parsed . scheme and not parsed . netloc : return relative_url ( from_url , url ) return url def on_config ( self , config : Config , ** kwargs ) -> Config : # noqa: W0613,R0201 (unused arguments, cannot be static) \"\"\"Instantiate our Markdown extension. Hook for the [`on_config` event](https://www.mkdocs.org/user-guide/plugins/#on_config). In this hook, we instantiate our [`AutorefsExtension`][mkdocs_autorefs.references.AutorefsExtension] and add it to the list of Markdown extensions used by `mkdocs`. Arguments: config: The MkDocs config object. kwargs: Additional arguments passed by MkDocs. Returns: The modified config. \"\"\" log . debug ( f \" { __name__ } : Adding AutorefsExtension to the list\" ) config [ \"markdown_extensions\" ] . append ( AutorefsExtension ()) return config def on_page_markdown ( self , markdown : str , page : Page , ** kwargs ) -> str : # noqa: W0613 (unused arguments) \"\"\"Remember which page is the current one. Arguments: markdown: Input Markdown. page: The related MkDocs page instance. kwargs: Additional arguments passed by MkDocs. Returns: The same Markdown. We only use this hook to map anchors to URLs. \"\"\" self . current_page = page . url # noqa: WPS601 return markdown def on_page_content ( self , html : str , page : Page , ** kwargs ) -> str : # noqa: W0613 (unused arguments) \"\"\"Map anchors to URLs. Hook for the [`on_page_content` event](https://www.mkdocs.org/user-guide/plugins/#on_page_content). In this hook, we map the IDs of every anchor found in the table of contents to the anchors absolute URLs. This mapping will be used later to fix unresolved reference of the form `[title][identifier]` or `[identifier][]`. Arguments: html: HTML converted from Markdown. page: The related MkDocs page instance. kwargs: Additional arguments passed by MkDocs. Returns: The same HTML. We only use this hook to map anchors to URLs. \"\"\" if self . scan_toc : log . debug ( f \" { __name__ } : Mapping identifiers to URLs for page { page . file . src_path } \" ) for item in page . toc . items : self . map_urls ( page . url , item ) return html def map_urls ( self , base_url : str , anchor : AnchorLink ) -> None : \"\"\"Recurse on every anchor to map its ID to its absolute URL. This method populates `self.url_map` by side-effect. Arguments: base_url: The base URL to use as a prefix for each anchor's relative URL. anchor: The anchor to process and to recurse on. \"\"\" self . register_anchor ( base_url , anchor . id ) for child in anchor . children : self . map_urls ( base_url , child ) def on_post_page ( self , output : str , page : Page , ** kwargs ) -> str : # noqa: W0613 (unused arguments) \"\"\"Fix cross-references. Hook for the [`on_post_page` event](https://www.mkdocs.org/user-guide/plugins/#on_post_page). In this hook, we try to fix unresolved references of the form `[title][identifier]` or `[identifier][]`. Doing that allows the user of `autorefs` to cross-reference objects in their documentation strings. It uses the native Markdown syntax so it's easy to remember and use. We log a warning for each reference that we couldn't map to an URL, but try to be smart and ignore identifiers that do not look legitimate (sometimes documentation can contain strings matching our [`AUTO_REF_RE`][mkdocs_autorefs.references.AUTO_REF_RE] regular expression that did not intend to reference anything). We currently ignore references when their identifier contains a space or a slash. Arguments: output: HTML converted from Markdown. page: The related MkDocs page instance. kwargs: Additional arguments passed by MkDocs. Returns: Modified HTML. \"\"\" log . debug ( f \" { __name__ } : Fixing references in page { page . file . src_path } \" ) url_mapper = functools . partial ( self . get_item_url , from_url = page . url , fallback = self . get_fallback_anchor ) fixed_output , unmapped = fix_refs ( output , url_mapper ) if unmapped and log . isEnabledFor ( logging . WARNING ): for ref in unmapped : log . warning ( f \" { __name__ } : { page . file . src_path } : Could not find cross-reference target '[ { ref } ]'\" , ) return fixed_output","title":"AutorefsPlugin"},{"location":"reference/mkdocs_autorefs/plugin/#mkdocs_autorefs.plugin.AutorefsPlugin.__init__","text":"Initialize the object. Source code in mkdocs_autorefs/plugin.py def __init__ ( self ) -> None : \"\"\"Initialize the object.\"\"\" super () . __init__ () self . _url_map : Dict [ str , str ] = {} self . _abs_url_map : Dict [ str , str ] = {} self . get_fallback_anchor : Optional [ Callable [[ str ], Optional [ str ]]] = None # noqa: WPS234","title":"__init__()"},{"location":"reference/mkdocs_autorefs/plugin/#mkdocs_autorefs.plugin.AutorefsPlugin.get_item_url","text":"Return a site-relative URL with anchor to the identifier, if it's present anywhere. Parameters: Name Type Description Default identifier str The anchor (without '#'). required from_url Optional[str] The URL of the base page, from which we link towards the targeted pages. None fallback Optional[Callable[[str], Sequence[str]]] An optional function to suggest alternative anchors to try on failure. None Returns: Type Description str A site-relative URL. Source code in mkdocs_autorefs/plugin.py def get_item_url ( # noqa: WPS234 self , identifier : str , from_url : Optional [ str ] = None , fallback : Optional [ Callable [[ str ], Sequence [ str ]]] = None , ) -> str : \"\"\"Return a site-relative URL with anchor to the identifier, if it's present anywhere. Arguments: identifier: The anchor (without '#'). from_url: The URL of the base page, from which we link towards the targeted pages. fallback: An optional function to suggest alternative anchors to try on failure. Returns: A site-relative URL. \"\"\" url = self . _get_item_url ( identifier , fallback ) if from_url is not None : parsed = urlsplit ( url ) if not parsed . scheme and not parsed . netloc : return relative_url ( from_url , url ) return url","title":"get_item_url()"},{"location":"reference/mkdocs_autorefs/plugin/#mkdocs_autorefs.plugin.AutorefsPlugin.map_urls","text":"Recurse on every anchor to map its ID to its absolute URL. This method populates self.url_map by side-effect. Parameters: Name Type Description Default base_url str The base URL to use as a prefix for each anchor's relative URL. required anchor AnchorLink The anchor to process and to recurse on. required Source code in mkdocs_autorefs/plugin.py def map_urls ( self , base_url : str , anchor : AnchorLink ) -> None : \"\"\"Recurse on every anchor to map its ID to its absolute URL. This method populates `self.url_map` by side-effect. Arguments: base_url: The base URL to use as a prefix for each anchor's relative URL. anchor: The anchor to process and to recurse on. \"\"\" self . register_anchor ( base_url , anchor . id ) for child in anchor . children : self . map_urls ( base_url , child )","title":"map_urls()"},{"location":"reference/mkdocs_autorefs/plugin/#mkdocs_autorefs.plugin.AutorefsPlugin.on_config","text":"Instantiate our Markdown extension. Hook for the on_config event . In this hook, we instantiate our AutorefsExtension and add it to the list of Markdown extensions used by mkdocs . Parameters: Name Type Description Default config Config The MkDocs config object. required kwargs Additional arguments passed by MkDocs. {} Returns: Type Description Config The modified config. Source code in mkdocs_autorefs/plugin.py def on_config ( self , config : Config , ** kwargs ) -> Config : # noqa: W0613,R0201 (unused arguments, cannot be static) \"\"\"Instantiate our Markdown extension. Hook for the [`on_config` event](https://www.mkdocs.org/user-guide/plugins/#on_config). In this hook, we instantiate our [`AutorefsExtension`][mkdocs_autorefs.references.AutorefsExtension] and add it to the list of Markdown extensions used by `mkdocs`. Arguments: config: The MkDocs config object. kwargs: Additional arguments passed by MkDocs. Returns: The modified config. \"\"\" log . debug ( f \" { __name__ } : Adding AutorefsExtension to the list\" ) config [ \"markdown_extensions\" ] . append ( AutorefsExtension ()) return config","title":"on_config()"},{"location":"reference/mkdocs_autorefs/plugin/#mkdocs_autorefs.plugin.AutorefsPlugin.on_page_content","text":"Map anchors to URLs. Hook for the on_page_content event . In this hook, we map the IDs of every anchor found in the table of contents to the anchors absolute URLs. This mapping will be used later to fix unresolved reference of the form [title][identifier] or [identifier][] . Parameters: Name Type Description Default html str HTML converted from Markdown. required page Page The related MkDocs page instance. required kwargs Additional arguments passed by MkDocs. {} Returns: Type Description str The same HTML. We only use this hook to map anchors to URLs. Source code in mkdocs_autorefs/plugin.py def on_page_content ( self , html : str , page : Page , ** kwargs ) -> str : # noqa: W0613 (unused arguments) \"\"\"Map anchors to URLs. Hook for the [`on_page_content` event](https://www.mkdocs.org/user-guide/plugins/#on_page_content). In this hook, we map the IDs of every anchor found in the table of contents to the anchors absolute URLs. This mapping will be used later to fix unresolved reference of the form `[title][identifier]` or `[identifier][]`. Arguments: html: HTML converted from Markdown. page: The related MkDocs page instance. kwargs: Additional arguments passed by MkDocs. Returns: The same HTML. We only use this hook to map anchors to URLs. \"\"\" if self . scan_toc : log . debug ( f \" { __name__ } : Mapping identifiers to URLs for page { page . file . src_path } \" ) for item in page . toc . items : self . map_urls ( page . url , item ) return html","title":"on_page_content()"},{"location":"reference/mkdocs_autorefs/plugin/#mkdocs_autorefs.plugin.AutorefsPlugin.on_page_markdown","text":"Remember which page is the current one. Parameters: Name Type Description Default markdown str Input Markdown. required page Page The related MkDocs page instance. required kwargs Additional arguments passed by MkDocs. {} Returns: Type Description str The same Markdown. We only use this hook to map anchors to URLs. Source code in mkdocs_autorefs/plugin.py def on_page_markdown ( self , markdown : str , page : Page , ** kwargs ) -> str : # noqa: W0613 (unused arguments) \"\"\"Remember which page is the current one. Arguments: markdown: Input Markdown. page: The related MkDocs page instance. kwargs: Additional arguments passed by MkDocs. Returns: The same Markdown. We only use this hook to map anchors to URLs. \"\"\" self . current_page = page . url # noqa: WPS601 return markdown","title":"on_page_markdown()"},{"location":"reference/mkdocs_autorefs/plugin/#mkdocs_autorefs.plugin.AutorefsPlugin.on_post_page","text":"Fix cross-references. Hook for the on_post_page event . In this hook, we try to fix unresolved references of the form [title][identifier] or [identifier][] . Doing that allows the user of autorefs to cross-reference objects in their documentation strings. It uses the native Markdown syntax so it's easy to remember and use. We log a warning for each reference that we couldn't map to an URL, but try to be smart and ignore identifiers that do not look legitimate (sometimes documentation can contain strings matching our AUTO_REF_RE regular expression that did not intend to reference anything). We currently ignore references when their identifier contains a space or a slash. Parameters: Name Type Description Default output str HTML converted from Markdown. required page Page The related MkDocs page instance. required kwargs Additional arguments passed by MkDocs. {} Returns: Type Description str Modified HTML. Source code in mkdocs_autorefs/plugin.py def on_post_page ( self , output : str , page : Page , ** kwargs ) -> str : # noqa: W0613 (unused arguments) \"\"\"Fix cross-references. Hook for the [`on_post_page` event](https://www.mkdocs.org/user-guide/plugins/#on_post_page). In this hook, we try to fix unresolved references of the form `[title][identifier]` or `[identifier][]`. Doing that allows the user of `autorefs` to cross-reference objects in their documentation strings. It uses the native Markdown syntax so it's easy to remember and use. We log a warning for each reference that we couldn't map to an URL, but try to be smart and ignore identifiers that do not look legitimate (sometimes documentation can contain strings matching our [`AUTO_REF_RE`][mkdocs_autorefs.references.AUTO_REF_RE] regular expression that did not intend to reference anything). We currently ignore references when their identifier contains a space or a slash. Arguments: output: HTML converted from Markdown. page: The related MkDocs page instance. kwargs: Additional arguments passed by MkDocs. Returns: Modified HTML. \"\"\" log . debug ( f \" { __name__ } : Fixing references in page { page . file . src_path } \" ) url_mapper = functools . partial ( self . get_item_url , from_url = page . url , fallback = self . get_fallback_anchor ) fixed_output , unmapped = fix_refs ( output , url_mapper ) if unmapped and log . isEnabledFor ( logging . WARNING ): for ref in unmapped : log . warning ( f \" { __name__ } : { page . file . src_path } : Could not find cross-reference target '[ { ref } ]'\" , ) return fixed_output","title":"on_post_page()"},{"location":"reference/mkdocs_autorefs/plugin/#mkdocs_autorefs.plugin.AutorefsPlugin.register_anchor","text":"Register that an anchor corresponding to an identifier was encountered when rendering the page. Parameters: Name Type Description Default page str The relative URL of the current page. Examples: 'foo/bar/' , 'foo/index.html' required identifier str The HTML anchor (without '#') as a string. required Source code in mkdocs_autorefs/plugin.py def register_anchor ( self , page : str , identifier : str ): \"\"\"Register that an anchor corresponding to an identifier was encountered when rendering the page. Arguments: page: The relative URL of the current page. Examples: `'foo/bar/'`, `'foo/index.html'` identifier: The HTML anchor (without '#') as a string. \"\"\" self . _url_map [ identifier ] = f \" { page } # { identifier } \"","title":"register_anchor()"},{"location":"reference/mkdocs_autorefs/plugin/#mkdocs_autorefs.plugin.AutorefsPlugin.register_url","text":"Register that the identifier should be turned into a link to this URL. Parameters: Name Type Description Default identifier str The new identifier. required url str The absolute URL (including anchor, if needed) where this item can be found. required Source code in mkdocs_autorefs/plugin.py def register_url ( self , identifier : str , url : str ): \"\"\"Register that the identifier should be turned into a link to this URL. Arguments: identifier: The new identifier. url: The absolute URL (including anchor, if needed) where this item can be found. \"\"\" self . _abs_url_map [ identifier ] = url","title":"register_url()"},{"location":"reference/mkdocs_autorefs/references/","text":"Cross-references module. AUTO_REF_RE \u00a4 A regular expression to match mkdocs-autorefs' special reference markers in the on_post_page hook . AutoRefInlineProcessor ( ReferenceInlineProcessor ) \u00a4 A Markdown extension. Source code in mkdocs_autorefs/references.py class AutoRefInlineProcessor ( ReferenceInlineProcessor ): \"\"\"A Markdown extension.\"\"\" def __init__ ( self , * args , ** kwargs ): # noqa: D107 super () . __init__ ( REFERENCE_RE , * args , ** kwargs ) # Code based on # https://github.com/Python-Markdown/markdown/blob/8e7528fa5c98bf4652deb13206d6e6241d61630b/markdown/inlinepatterns.py#L780 def handleMatch ( self , m , data ) -> Union [ Element , EvalIDType ]: # type: ignore[override] # noqa: N802,WPS111 \"\"\"Handle an element that matched. Arguments: m: The match object. data: The matched data. Returns: A new element or a tuple. \"\"\" text , index , handled = self . getText ( data , m . end ( 0 )) if not handled : return None , None , None identifier , end , handled = self . evalId ( data , index , text ) if not handled : return None , None , None if re . search ( r \"[/ \\x00-\\x1f]\" , identifier ): # Do nothing if the matched reference contains: # - a space, slash or control character (considered unintended); # - specifically \\x01 is used by Python-Markdown HTML stash when there's inline formatting, # but references with Markdown formatting are not possible anyway. return None , m . start ( 0 ), end return self . makeTag ( identifier , text ), m . start ( 0 ), end def evalId ( self , data : str , index : int , text : str ) -> EvalIDType : # noqa: N802 (parent's casing) \"\"\"Evaluate the id portion of `[ref][id]`. If `[ref][]` use `[ref]`. Arguments: data: The data to evaluate. index: The starting position. text: The text to use when no identifier. Returns: A tuple containing the identifier, its end position, and whether it matched. \"\"\" m = self . RE_LINK . match ( data , pos = index ) # noqa: WPS111 if not m : return None , index , False identifier = m . group ( 1 ) if not identifier : identifier = text # Allow the entire content to be one placeholder, with the intent of catching things like [`Foo`][]. # It doesn't catch [*Foo*][] though, just due to the priority order. # https://github.com/Python-Markdown/markdown/blob/1858c1b601ead62ed49646ae0d99298f41b1a271/markdown/inlinepatterns.py#L78 if INLINE_PLACEHOLDER_RE . fullmatch ( identifier ): identifier = self . unescape ( identifier ) end = m . end ( 0 ) return identifier , end , True def makeTag ( self , identifier : str , text : str ) -> Element : # type: ignore[override] # noqa: N802,W0221 \"\"\"Create a tag that can be matched by `AUTO_REF_RE`. Arguments: identifier: The identifier to use in the HTML property. text: The text to use in the HTML tag. Returns: A new element. \"\"\" el = Element ( \"span\" ) el . set ( \"data-autorefs-identifier\" , identifier ) el . text = text return el evalId ( self , data , index , text ) \u00a4 Evaluate the id portion of [ref][id] . If [ref][] use [ref] . Parameters: Name Type Description Default data str The data to evaluate. required index int The starting position. required text str The text to use when no identifier. required Returns: Type Description Tuple[Any, Any, Any] A tuple containing the identifier, its end position, and whether it matched. Source code in mkdocs_autorefs/references.py def evalId ( self , data : str , index : int , text : str ) -> EvalIDType : # noqa: N802 (parent's casing) \"\"\"Evaluate the id portion of `[ref][id]`. If `[ref][]` use `[ref]`. Arguments: data: The data to evaluate. index: The starting position. text: The text to use when no identifier. Returns: A tuple containing the identifier, its end position, and whether it matched. \"\"\" m = self . RE_LINK . match ( data , pos = index ) # noqa: WPS111 if not m : return None , index , False identifier = m . group ( 1 ) if not identifier : identifier = text # Allow the entire content to be one placeholder, with the intent of catching things like [`Foo`][]. # It doesn't catch [*Foo*][] though, just due to the priority order. # https://github.com/Python-Markdown/markdown/blob/1858c1b601ead62ed49646ae0d99298f41b1a271/markdown/inlinepatterns.py#L78 if INLINE_PLACEHOLDER_RE . fullmatch ( identifier ): identifier = self . unescape ( identifier ) end = m . end ( 0 ) return identifier , end , True handleMatch ( self , m , data ) \u00a4 Handle an element that matched. Parameters: Name Type Description Default m The match object. required data The matched data. required Returns: Type Description Union[xml.etree.ElementTree.Element, Tuple[Any, Any, Any]] A new element or a tuple. Source code in mkdocs_autorefs/references.py def handleMatch ( self , m , data ) -> Union [ Element , EvalIDType ]: # type: ignore[override] # noqa: N802,WPS111 \"\"\"Handle an element that matched. Arguments: m: The match object. data: The matched data. Returns: A new element or a tuple. \"\"\" text , index , handled = self . getText ( data , m . end ( 0 )) if not handled : return None , None , None identifier , end , handled = self . evalId ( data , index , text ) if not handled : return None , None , None if re . search ( r \"[/ \\x00-\\x1f]\" , identifier ): # Do nothing if the matched reference contains: # - a space, slash or control character (considered unintended); # - specifically \\x01 is used by Python-Markdown HTML stash when there's inline formatting, # but references with Markdown formatting are not possible anyway. return None , m . start ( 0 ), end return self . makeTag ( identifier , text ), m . start ( 0 ), end makeTag ( self , identifier , text ) \u00a4 Create a tag that can be matched by AUTO_REF_RE . Parameters: Name Type Description Default identifier str The identifier to use in the HTML property. required text str The text to use in the HTML tag. required Returns: Type Description Element A new element. Source code in mkdocs_autorefs/references.py def makeTag ( self , identifier : str , text : str ) -> Element : # type: ignore[override] # noqa: N802,W0221 \"\"\"Create a tag that can be matched by `AUTO_REF_RE`. Arguments: identifier: The identifier to use in the HTML property. text: The text to use in the HTML tag. Returns: A new element. \"\"\" el = Element ( \"span\" ) el . set ( \"data-autorefs-identifier\" , identifier ) el . text = text return el AutorefsExtension ( Extension ) \u00a4 Extension that inserts auto-references in Markdown. Source code in mkdocs_autorefs/references.py class AutorefsExtension ( Extension ): \"\"\"Extension that inserts auto-references in Markdown.\"\"\" def extendMarkdown ( self , md : Markdown ) -> None : # noqa: N802 (casing: parent method's name) \"\"\"Register the extension. Add an instance of our [`AutoRefInlineProcessor`][mkdocs_autorefs.references.AutoRefInlineProcessor] to the Markdown parser. Arguments: md: A `markdown.Markdown` instance. \"\"\" md . inlinePatterns . register ( AutoRefInlineProcessor ( md ), \"mkdocs-autorefs\" , priority = 168 , # noqa: WPS432 # Right after markdown.inlinepatterns.ReferenceInlineProcessor ) extendMarkdown ( self , md ) \u00a4 Register the extension. Add an instance of our AutoRefInlineProcessor to the Markdown parser. Parameters: Name Type Description Default md Markdown A markdown.Markdown instance. required Source code in mkdocs_autorefs/references.py def extendMarkdown ( self , md : Markdown ) -> None : # noqa: N802 (casing: parent method's name) \"\"\"Register the extension. Add an instance of our [`AutoRefInlineProcessor`][mkdocs_autorefs.references.AutoRefInlineProcessor] to the Markdown parser. Arguments: md: A `markdown.Markdown` instance. \"\"\" md . inlinePatterns . register ( AutoRefInlineProcessor ( md ), \"mkdocs-autorefs\" , priority = 168 , # noqa: WPS432 # Right after markdown.inlinepatterns.ReferenceInlineProcessor ) fix_ref ( url_mapper , unmapped ) \u00a4 Return a repl function for re.sub . In our context, we match Markdown references and replace them with HTML links. When the matched reference's identifier was not mapped to an URL, we append the identifier to the outer unmapped list. It generally means the user is trying to cross-reference an object that was not collected and rendered, making it impossible to link to it. We catch this exception in the caller to issue a warning. Parameters: Name Type Description Default url_mapper Callable[[str], str] A callable that gets an object's site URL by its identifier, such as mkdocs_autorefs.plugin.AutorefsPlugin.get_item_url . required unmapped List[str] A list to store unmapped identifiers. required Returns: Type Description The actual function accepting a [`Match` object](https //docs.python.org/3/library/re.html#match-objects) and returning the replacement strings. Source code in mkdocs_autorefs/references.py def fix_ref ( url_mapper : Callable [[ str ], str ], unmapped : List [ str ]) -> Callable : # noqa: WPS212,WPS231 \"\"\"Return a `repl` function for [`re.sub`](https://docs.python.org/3/library/re.html#re.sub). In our context, we match Markdown references and replace them with HTML links. When the matched reference's identifier was not mapped to an URL, we append the identifier to the outer `unmapped` list. It generally means the user is trying to cross-reference an object that was not collected and rendered, making it impossible to link to it. We catch this exception in the caller to issue a warning. Arguments: url_mapper: A callable that gets an object's site URL by its identifier, such as [mkdocs_autorefs.plugin.AutorefsPlugin.get_item_url][]. unmapped: A list to store unmapped identifiers. Returns: The actual function accepting a [`Match` object](https://docs.python.org/3/library/re.html#match-objects) and returning the replacement strings. \"\"\" def inner ( match : Match ): # noqa: WPS212,WPS430 identifier = match [ \"identifier\" ] title = match [ \"title\" ] kind = match [ \"kind\" ] try : url = url_mapper ( unescape ( identifier )) except KeyError : if kind == \"autorefs-optional\" : return title elif kind == \"autorefs-optional-hover\" : return f '<span title=\" { identifier } \"> { title } </span>' unmapped . append ( identifier ) if title == identifier : return f \"[ { identifier } ][]\" return f \"[ { title } ][ { identifier } ]\" parsed = urlsplit ( url ) external = parsed . scheme or parsed . netloc classes = [ \"autorefs\" , \"autorefs-external\" if external else \"autorefs-internal\" ] class_attr = \" \" . join ( classes ) if kind == \"autorefs-optional-hover\" : return f '<a class=\" { class_attr } \" title=\" { identifier } \" href=\" { escape ( url ) } \"> { title } </a>' return f '<a class=\" { class_attr } \" href=\" { escape ( url ) } \"> { title } </a>' return inner fix_refs ( html , url_mapper ) \u00a4 Fix all references in the given HTML text. Parameters: Name Type Description Default html str The text to fix. required url_mapper Callable[[str], str] A callable that gets an object's site URL by its identifier, such as mkdocs_autorefs.plugin.AutorefsPlugin.get_item_url . required Returns: Type Description Tuple[str, List[str]] The fixed HTML. Source code in mkdocs_autorefs/references.py def fix_refs ( html : str , url_mapper : Callable [[ str ], str ]) -> Tuple [ str , List [ str ]]: \"\"\"Fix all references in the given HTML text. Arguments: html: The text to fix. url_mapper: A callable that gets an object's site URL by its identifier, such as [mkdocs_autorefs.plugin.AutorefsPlugin.get_item_url][]. Returns: The fixed HTML. \"\"\" unmapped = [] # type: ignore html = AUTO_REF_RE . sub ( fix_ref ( url_mapper , unmapped ), html ) return html , unmapped relative_url ( url_a , url_b ) \u00a4 Compute the relative path from URL A to URL B. Parameters: Name Type Description Default url_a str URL A. required url_b str URL B. required Returns: Type Description str The relative URL to go from A to B. Source code in mkdocs_autorefs/references.py def relative_url ( url_a : str , url_b : str ) -> str : \"\"\"Compute the relative path from URL A to URL B. Arguments: url_a: URL A. url_b: URL B. Returns: The relative URL to go from A to B. \"\"\" parts_a = url_a . split ( \"/\" ) url_b , anchor = url_b . split ( \"#\" , 1 ) parts_b = url_b . split ( \"/\" ) # remove common left parts while parts_a and parts_b and parts_a [ 0 ] == parts_b [ 0 ]: parts_a . pop ( 0 ) parts_b . pop ( 0 ) # go up as many times as remaining a parts' depth levels = len ( parts_a ) - 1 parts_relative = [ \"..\" ] * levels + parts_b # noqa: WPS435 relative = \"/\" . join ( parts_relative ) return f \" { relative } # { anchor } \"","title":"references"},{"location":"reference/mkdocs_autorefs/references/#mkdocs_autorefs.references.AUTO_REF_RE","text":"A regular expression to match mkdocs-autorefs' special reference markers in the on_post_page hook .","title":"AUTO_REF_RE"},{"location":"reference/mkdocs_autorefs/references/#mkdocs_autorefs.references.AutoRefInlineProcessor","text":"A Markdown extension. Source code in mkdocs_autorefs/references.py class AutoRefInlineProcessor ( ReferenceInlineProcessor ): \"\"\"A Markdown extension.\"\"\" def __init__ ( self , * args , ** kwargs ): # noqa: D107 super () . __init__ ( REFERENCE_RE , * args , ** kwargs ) # Code based on # https://github.com/Python-Markdown/markdown/blob/8e7528fa5c98bf4652deb13206d6e6241d61630b/markdown/inlinepatterns.py#L780 def handleMatch ( self , m , data ) -> Union [ Element , EvalIDType ]: # type: ignore[override] # noqa: N802,WPS111 \"\"\"Handle an element that matched. Arguments: m: The match object. data: The matched data. Returns: A new element or a tuple. \"\"\" text , index , handled = self . getText ( data , m . end ( 0 )) if not handled : return None , None , None identifier , end , handled = self . evalId ( data , index , text ) if not handled : return None , None , None if re . search ( r \"[/ \\x00-\\x1f]\" , identifier ): # Do nothing if the matched reference contains: # - a space, slash or control character (considered unintended); # - specifically \\x01 is used by Python-Markdown HTML stash when there's inline formatting, # but references with Markdown formatting are not possible anyway. return None , m . start ( 0 ), end return self . makeTag ( identifier , text ), m . start ( 0 ), end def evalId ( self , data : str , index : int , text : str ) -> EvalIDType : # noqa: N802 (parent's casing) \"\"\"Evaluate the id portion of `[ref][id]`. If `[ref][]` use `[ref]`. Arguments: data: The data to evaluate. index: The starting position. text: The text to use when no identifier. Returns: A tuple containing the identifier, its end position, and whether it matched. \"\"\" m = self . RE_LINK . match ( data , pos = index ) # noqa: WPS111 if not m : return None , index , False identifier = m . group ( 1 ) if not identifier : identifier = text # Allow the entire content to be one placeholder, with the intent of catching things like [`Foo`][]. # It doesn't catch [*Foo*][] though, just due to the priority order. # https://github.com/Python-Markdown/markdown/blob/1858c1b601ead62ed49646ae0d99298f41b1a271/markdown/inlinepatterns.py#L78 if INLINE_PLACEHOLDER_RE . fullmatch ( identifier ): identifier = self . unescape ( identifier ) end = m . end ( 0 ) return identifier , end , True def makeTag ( self , identifier : str , text : str ) -> Element : # type: ignore[override] # noqa: N802,W0221 \"\"\"Create a tag that can be matched by `AUTO_REF_RE`. Arguments: identifier: The identifier to use in the HTML property. text: The text to use in the HTML tag. Returns: A new element. \"\"\" el = Element ( \"span\" ) el . set ( \"data-autorefs-identifier\" , identifier ) el . text = text return el","title":"AutoRefInlineProcessor"},{"location":"reference/mkdocs_autorefs/references/#mkdocs_autorefs.references.AutoRefInlineProcessor.evalId","text":"Evaluate the id portion of [ref][id] . If [ref][] use [ref] . Parameters: Name Type Description Default data str The data to evaluate. required index int The starting position. required text str The text to use when no identifier. required Returns: Type Description Tuple[Any, Any, Any] A tuple containing the identifier, its end position, and whether it matched. Source code in mkdocs_autorefs/references.py def evalId ( self , data : str , index : int , text : str ) -> EvalIDType : # noqa: N802 (parent's casing) \"\"\"Evaluate the id portion of `[ref][id]`. If `[ref][]` use `[ref]`. Arguments: data: The data to evaluate. index: The starting position. text: The text to use when no identifier. Returns: A tuple containing the identifier, its end position, and whether it matched. \"\"\" m = self . RE_LINK . match ( data , pos = index ) # noqa: WPS111 if not m : return None , index , False identifier = m . group ( 1 ) if not identifier : identifier = text # Allow the entire content to be one placeholder, with the intent of catching things like [`Foo`][]. # It doesn't catch [*Foo*][] though, just due to the priority order. # https://github.com/Python-Markdown/markdown/blob/1858c1b601ead62ed49646ae0d99298f41b1a271/markdown/inlinepatterns.py#L78 if INLINE_PLACEHOLDER_RE . fullmatch ( identifier ): identifier = self . unescape ( identifier ) end = m . end ( 0 ) return identifier , end , True","title":"evalId()"},{"location":"reference/mkdocs_autorefs/references/#mkdocs_autorefs.references.AutoRefInlineProcessor.handleMatch","text":"Handle an element that matched. Parameters: Name Type Description Default m The match object. required data The matched data. required Returns: Type Description Union[xml.etree.ElementTree.Element, Tuple[Any, Any, Any]] A new element or a tuple. Source code in mkdocs_autorefs/references.py def handleMatch ( self , m , data ) -> Union [ Element , EvalIDType ]: # type: ignore[override] # noqa: N802,WPS111 \"\"\"Handle an element that matched. Arguments: m: The match object. data: The matched data. Returns: A new element or a tuple. \"\"\" text , index , handled = self . getText ( data , m . end ( 0 )) if not handled : return None , None , None identifier , end , handled = self . evalId ( data , index , text ) if not handled : return None , None , None if re . search ( r \"[/ \\x00-\\x1f]\" , identifier ): # Do nothing if the matched reference contains: # - a space, slash or control character (considered unintended); # - specifically \\x01 is used by Python-Markdown HTML stash when there's inline formatting, # but references with Markdown formatting are not possible anyway. return None , m . start ( 0 ), end return self . makeTag ( identifier , text ), m . start ( 0 ), end","title":"handleMatch()"},{"location":"reference/mkdocs_autorefs/references/#mkdocs_autorefs.references.AutoRefInlineProcessor.makeTag","text":"Create a tag that can be matched by AUTO_REF_RE . Parameters: Name Type Description Default identifier str The identifier to use in the HTML property. required text str The text to use in the HTML tag. required Returns: Type Description Element A new element. Source code in mkdocs_autorefs/references.py def makeTag ( self , identifier : str , text : str ) -> Element : # type: ignore[override] # noqa: N802,W0221 \"\"\"Create a tag that can be matched by `AUTO_REF_RE`. Arguments: identifier: The identifier to use in the HTML property. text: The text to use in the HTML tag. Returns: A new element. \"\"\" el = Element ( \"span\" ) el . set ( \"data-autorefs-identifier\" , identifier ) el . text = text return el","title":"makeTag()"},{"location":"reference/mkdocs_autorefs/references/#mkdocs_autorefs.references.AutorefsExtension","text":"Extension that inserts auto-references in Markdown. Source code in mkdocs_autorefs/references.py class AutorefsExtension ( Extension ): \"\"\"Extension that inserts auto-references in Markdown.\"\"\" def extendMarkdown ( self , md : Markdown ) -> None : # noqa: N802 (casing: parent method's name) \"\"\"Register the extension. Add an instance of our [`AutoRefInlineProcessor`][mkdocs_autorefs.references.AutoRefInlineProcessor] to the Markdown parser. Arguments: md: A `markdown.Markdown` instance. \"\"\" md . inlinePatterns . register ( AutoRefInlineProcessor ( md ), \"mkdocs-autorefs\" , priority = 168 , # noqa: WPS432 # Right after markdown.inlinepatterns.ReferenceInlineProcessor )","title":"AutorefsExtension"},{"location":"reference/mkdocs_autorefs/references/#mkdocs_autorefs.references.AutorefsExtension.extendMarkdown","text":"Register the extension. Add an instance of our AutoRefInlineProcessor to the Markdown parser. Parameters: Name Type Description Default md Markdown A markdown.Markdown instance. required Source code in mkdocs_autorefs/references.py def extendMarkdown ( self , md : Markdown ) -> None : # noqa: N802 (casing: parent method's name) \"\"\"Register the extension. Add an instance of our [`AutoRefInlineProcessor`][mkdocs_autorefs.references.AutoRefInlineProcessor] to the Markdown parser. Arguments: md: A `markdown.Markdown` instance. \"\"\" md . inlinePatterns . register ( AutoRefInlineProcessor ( md ), \"mkdocs-autorefs\" , priority = 168 , # noqa: WPS432 # Right after markdown.inlinepatterns.ReferenceInlineProcessor )","title":"extendMarkdown()"},{"location":"reference/mkdocs_autorefs/references/#mkdocs_autorefs.references.fix_ref","text":"Return a repl function for re.sub . In our context, we match Markdown references and replace them with HTML links. When the matched reference's identifier was not mapped to an URL, we append the identifier to the outer unmapped list. It generally means the user is trying to cross-reference an object that was not collected and rendered, making it impossible to link to it. We catch this exception in the caller to issue a warning. Parameters: Name Type Description Default url_mapper Callable[[str], str] A callable that gets an object's site URL by its identifier, such as mkdocs_autorefs.plugin.AutorefsPlugin.get_item_url . required unmapped List[str] A list to store unmapped identifiers. required Returns: Type Description The actual function accepting a [`Match` object](https //docs.python.org/3/library/re.html#match-objects) and returning the replacement strings. Source code in mkdocs_autorefs/references.py def fix_ref ( url_mapper : Callable [[ str ], str ], unmapped : List [ str ]) -> Callable : # noqa: WPS212,WPS231 \"\"\"Return a `repl` function for [`re.sub`](https://docs.python.org/3/library/re.html#re.sub). In our context, we match Markdown references and replace them with HTML links. When the matched reference's identifier was not mapped to an URL, we append the identifier to the outer `unmapped` list. It generally means the user is trying to cross-reference an object that was not collected and rendered, making it impossible to link to it. We catch this exception in the caller to issue a warning. Arguments: url_mapper: A callable that gets an object's site URL by its identifier, such as [mkdocs_autorefs.plugin.AutorefsPlugin.get_item_url][]. unmapped: A list to store unmapped identifiers. Returns: The actual function accepting a [`Match` object](https://docs.python.org/3/library/re.html#match-objects) and returning the replacement strings. \"\"\" def inner ( match : Match ): # noqa: WPS212,WPS430 identifier = match [ \"identifier\" ] title = match [ \"title\" ] kind = match [ \"kind\" ] try : url = url_mapper ( unescape ( identifier )) except KeyError : if kind == \"autorefs-optional\" : return title elif kind == \"autorefs-optional-hover\" : return f '<span title=\" { identifier } \"> { title } </span>' unmapped . append ( identifier ) if title == identifier : return f \"[ { identifier } ][]\" return f \"[ { title } ][ { identifier } ]\" parsed = urlsplit ( url ) external = parsed . scheme or parsed . netloc classes = [ \"autorefs\" , \"autorefs-external\" if external else \"autorefs-internal\" ] class_attr = \" \" . join ( classes ) if kind == \"autorefs-optional-hover\" : return f '<a class=\" { class_attr } \" title=\" { identifier } \" href=\" { escape ( url ) } \"> { title } </a>' return f '<a class=\" { class_attr } \" href=\" { escape ( url ) } \"> { title } </a>' return inner","title":"fix_ref()"},{"location":"reference/mkdocs_autorefs/references/#mkdocs_autorefs.references.fix_refs","text":"Fix all references in the given HTML text. Parameters: Name Type Description Default html str The text to fix. required url_mapper Callable[[str], str] A callable that gets an object's site URL by its identifier, such as mkdocs_autorefs.plugin.AutorefsPlugin.get_item_url . required Returns: Type Description Tuple[str, List[str]] The fixed HTML. Source code in mkdocs_autorefs/references.py def fix_refs ( html : str , url_mapper : Callable [[ str ], str ]) -> Tuple [ str , List [ str ]]: \"\"\"Fix all references in the given HTML text. Arguments: html: The text to fix. url_mapper: A callable that gets an object's site URL by its identifier, such as [mkdocs_autorefs.plugin.AutorefsPlugin.get_item_url][]. Returns: The fixed HTML. \"\"\" unmapped = [] # type: ignore html = AUTO_REF_RE . sub ( fix_ref ( url_mapper , unmapped ), html ) return html , unmapped","title":"fix_refs()"},{"location":"reference/mkdocs_autorefs/references/#mkdocs_autorefs.references.relative_url","text":"Compute the relative path from URL A to URL B. Parameters: Name Type Description Default url_a str URL A. required url_b str URL B. required Returns: Type Description str The relative URL to go from A to B. Source code in mkdocs_autorefs/references.py def relative_url ( url_a : str , url_b : str ) -> str : \"\"\"Compute the relative path from URL A to URL B. Arguments: url_a: URL A. url_b: URL B. Returns: The relative URL to go from A to B. \"\"\" parts_a = url_a . split ( \"/\" ) url_b , anchor = url_b . split ( \"#\" , 1 ) parts_b = url_b . split ( \"/\" ) # remove common left parts while parts_a and parts_b and parts_a [ 0 ] == parts_b [ 0 ]: parts_a . pop ( 0 ) parts_b . pop ( 0 ) # go up as many times as remaining a parts' depth levels = len ( parts_a ) - 1 parts_relative = [ \"..\" ] * levels + parts_b # noqa: WPS435 relative = \"/\" . join ( parts_relative ) return f \" { relative } # { anchor } \"","title":"relative_url()"},{"location":"coverage/","text":".md-content { max-width: none !important; } article h1, article > a { display: none; } var coviframe = document.getElementById(\"coviframe\"); function resizeIframe() { coviframe.style.height = coviframe.contentWindow.document.documentElement.offsetHeight + 'px'; } coviframe.contentWindow.document.body.onclick = function() { coviframe.contentWindow.location.reload(); }","title":"Coverage report"}]}